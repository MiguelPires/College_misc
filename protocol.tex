\section{Protocol}
%
\begin{definition}
(Multi-valued wait-free consensus with adversary $\mathcal{A}$)

A process is \emph{correct} with respect to crash adversary 
in an execution $E$ if it takes infinitely many steps in $E$.
%
\begin{itemize}
\item (Agreement): No two processes agree on different values  
\item (Liveness): Every correct process (w.r.t $\mathcal{A}$) 
eventually decides on a value previously proposed by a correct process (w.r.t $\mathcal{A}$).
\end{itemize}
%
\end{definition}
%
\input{algo_cft}
%
\newpage
We now present the adapted Generalized Paxos protocol for a Byzantine adversary.\par
\textbf{View Change} The goal of the view change sub-protocol is to ensure that when $f+1$ processes suspect the leader to be faulty all correct processes commit to a new view (i.e., a new ballot) and stop participating in lower-numbered ballots. To this end, processes can multicast suspicion messages if they believe that the leader is faulty. Suspicions contain the current view number signed by the sending process in a verifiable way. If a correct process receives $f+1$ suspicions then it stops participating in the previous ballot and multicasts a view-change message. View-change messages contain a ballot number, the previously committed ballot and value, and proof that the sending process has received $f+1$ suspicions. This proof consists in the signatures sent in each suspicion message. If a process receives a view-change message without previously receiving $f+1$ suspicions, it commits to the new view and multicasts a view-change message.  The proof allows a process that receives this message to commit to the new view and multicast its own view-change messages without receiving $f+1$ suspicions itself. The process must only confirm that the signatures are valid and correspond to suspicions sent by distinct processes for the current view. This guarantees that if one correct process received the $f+1$ suspicions and broadcasted the view-change message, then all correct processes will receive that message, validate the proof of $f+1$ suspicions and switch to the new view. Processes start participating in the new view as soon as they broadcast their view-change messages since the multicast of one correct view-change messages is all it takes to ensure that all correct process will eventually switch to the new view. The only processes that must wait for $2f+1$ view-change messages in the leader of the new view since, to send new sequences, it needs to know the last value and ballot for a quorum of acceptors.\par
\textbf{Proof} We can prove that $f+1$ suspicions trigger a new view successfully since as soon as one process receives those suspicions it will broadcast a view-change message containing a proof that $f+1$ processes suspect the leader. When other processes receive either the $f+1$ suspicions or the view-change message, they will broadcast their own view-change messages and start participating in the new view. Faulty processes alone can't force a new view since $f+1$ suspicions are required for any correct process to commit to the new view.\par
\textbf{Agreement Protocol} The consensus protocol allows processes to agree on equivalent sequences of commands. Each consensus instance is called a ballot which can be \textit{classic} or \textit{fast}. In classic ballots, a leader proposes a single sequence of commands which is learned by the learners. In fast ballots, multiple proposers can concurrently propose single commands to acceptors which send their votes to learners. Concurrency implies that acceptors may send votes in different orders but the protocol ensures that, as long as the resulting sequences are equivalent, the commands will be learned in two message delays. After a view change, the leader isn't required to execute the first phase as in traditional Paxos since it already contains the information regarding the last voted upon value. However, the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot. \par
\textbf{Classic Ballots} In a classic ballot, proposers send their proposed commands to the leader who sends a single sequence of commands to the acceptors. This sequence is built by appending the new proposals to a sequence committed in the previous ballot. This previous sequence is the longest sequence that was voted on by an acceptor in the previous ballot. The digest of the augmented sequence is signed by the leader and sent with the proposal. This ensures that when a leader gathers the state from the acceptors, even faulty ones can only report values sent by the leader of the view in which the sequence was sent. This means that Byzantine acceptors can't covertly insert commands in the command history. At most, they can send an out-of-date value along with its proof. However, since the leader must gather values and ballot numbers from at least $2f+1$ processes, some correct process that participated in the last ballot is guaranteed to respond correctly. Therefore, the leader can calculate which sequence to extend by finding the largest sequence of the $2f+1$ values. The leader sends the sequence to the acceptors which, in turn, verify and send it to the learners. The verification performed at the acceptors ensures that the previously voted on value is a prefix of the new sequence which is necessary to preserve the stability property. Additionally, the acceptors also verify that the value is correctly signed by the leader. After receiving $2f+1$ messages, the learners learn the value present in at least $f+1$ messages. \par
\textbf{Fast Ballots}
\input{algo_bft}