
\chapter{Introduction}
\section{Motivation}
One of the fundamental challenges for processes participating in a distributed computation is achieving \emph{consensus}: processes initially propose a value and must \emph{eventually agree} on one of the proposed values~\cite{vukolic2012quorum}. Despite being a theoretical problem, its solution is critical to many modern large-scale system since it allows data to be replicated among distributed processes. Systems such as Google's Chubby~\cite{Burrows2006}, Spanner~\cite{Corbett2012} and Apache's ZooKeeper~\cite{Hunt2010} use techniques like \acrfull{smr}~\cite{time-clocks,Schneider1990} to allow them to remain highly available even in the presence of faults and asynchronous communication channels. \acrshort{smr} implements a fault tolerant system by modeling its processes as state machines that must receive the same inputs, execute the same state transitions and output the same results. Usually, to ensure that every state machine transitions to the same states, consensus is used to guarantee that inputs are processed in the same order. This technique is widely used to implement fault tolerant services and it's one of the reasons why consensus is so important.\par
One of the most important contributions to this field is the \acrfull{flp} impossibility result that states that the \textit{wait-free} consensus problem is unsolvable in an asynchronous system even if only one process can fail~\cite{Fischer1985}. Lamport's Paxos algorithm is able to solve consensus, circumventing the \acrshort{flp} impossibility result, by ensuring that values are always safely decided while progress is only guaranteed when the system is synchronous for a sufficient amount of time~\cite{Lamport2001}. In other words, Paxos overcomes the \acrshort{flp} result by weakening the liveness condition since it can't guarantee that correct processes will decide a value in a finite number of steps. In Paxos, there are 3 types of processes: \textit{proposers}, which propose values to be committed; \textit{acceptors}, which vote on proposed values; and \textit{learners}, that learn values voted on by a quorum of acceptors.\par
Paxos~\cite{Lamport:1998}, arguably, is one of the most popular protocols for solving the consensus problem among fault-prone processes. The evolution of the Paxos protocol represents a unique chapter in the history of Computer Science. It was first described in 1989 through a technical report~\cite{paxos:tr}, and was only published a decade later~\cite{Lamport:1998}. Another long wait took place until the protocol started to be studied in depth and used by researchers in various fields, namely the distributed algorithms~\cite{Prisco:1997} and the distributed systems~\cite{petal} research communities. And finally, another decade later, the protocol made its way to the core of the implementation of the services that are used by millions of people over the Internet, in particular since Paxos-based state machine replication is the key component of Google's Chubby lock service~\cite{Burrows2006} and Megastore storage system~\cite{36971}, or the open source ZooKeeper project~\cite{Hunt2010}, used by Yahoo!\ among others. Arguably, the complexity of the presentation may have stood in the way of a faster
adoption of the protocol, and several attempts have been made at writing more concise explanations of it~\cite{Lamport2001,Renesse2011}.\par

More recently, several variants of Paxos have been proposed and studied. Two important lines of research can be highlighted in this regard. First, a series of papers hardened the protocol against malicious adversaries by solving consensus in a Byzantine fault
model~\cite{Martin2006,Lamport2011}. The importance of this line of research is now being confirmed as these protocols are now in widespread use in the context of cryptocurrencies and distributed ledger schemes such as blockchain~\cite{bitcoin}. Second, many proposals target improving the Paxos protocol by eliminating communication costs~\cite{Lamport2006}, including an important evolution of the protocol called Generalized
Paxos~\cite{Lamport2005}, which has the noteworthy aspect of having lower communication costs by leveraging a more general specification than traditional consensus 
that can lead to a weaker requirement in terms of ordering of commands across replicas. In particular, instead of forcing all processes to agree on the same value (as with traditional consensus), it allows processes to pick an increasing sequence of commands that differs from process to process in that commutative commands may appear in a different order. The practical importance of such weaker specifications is underlined
by significant research activity on the corresponding weaker consistency models for replicated systems~\cite{Ladin:1990,dynamo}.\par

Generalized consensus is a generalization of traditional consensus that abstracts the problem of agreeing on a single value to a problem of agreeing on a monotonically increasing set of values. This problem is defined in terms of a set of values called command structures, \textit{c-structs}~\cite{Lamport2005}. These structures allow for the formulation of different consensus problems, including specifications where commutative operations are allowed to be ordered differently at different replicas (i.e., command histories). The advantage of such a problem becomes clear when considering the optimization proposed in a protocol called Fast Paxos, where fast ballots are executed by having proposers propose directly to acceptors~\cite{Lamport2006}. By avoiding sending the proposal to the leader, values can be learned in the optimal number of two message delays. However, if two proposers concurrently propose different values to acceptors, a conflict arises and at least an additional message delay is required for the leader to solve it. This is the cost that Fast Paxos pays in order to commit values in a single round trip.  Generalized consensus allows us to reduce this cost, if we define the problem as one of agreeing on command histories. Since histories are considered equivalent if non-commutative operations are totally ordered, the only operations that force the leader to intervene are non-commutative ones. An additional advantage of the generalized consensus formulation stems from its generality and from the fact that we can use the Generalized Paxos protocol to solve it despite its high level of abstraction. This protocol can be used to solve any consensus problem that can be defined in terms of generalized consensus, not only the command history problem. The reason why Generalized Paxos can take advantage of the possibility of reordering commutative commands is that it allows acceptors to accept different but compatible \textit{c-structs}. Two \textit{c-structs} are considered to be compatible if they can later be extended to equivalent \textit{c-structs}. In command histories, if all non-commutative commands are totally ordered, then two \textit{c-structs} are considered equivalent. \par
One application of the generalized consensus specification can be to implement SMR using command histories to agree on equivalent sequences of operations. For instance, consider a system with four operations $\{A, B, C, D\}$ where $C$ and $D$ are non-commutative. If two proposers concurrently propose the operations $A$ and $B$, some acceptors could accept $A$ first and then $B$ and other acceptors could accept the operations in the inverse order. However, this would not be considered a conflict and the leader wouldn't have to intervene since the operations commute. If two proposers tried to commit $C$ and $D$, acceptors could accept them in different orders which would be considered a conflict since these operations are non-commutative. In this situation, no \textit{c-struct} would be chosen and the leader would be forced to intervene by initiating a higher-numbered ballot to commit either $w \bullet C \bullet D$ or $w \bullet D \bullet C$. It's important to note that this is only one possible application of the Generalized Paxos protocol and that this protocol solves any problem that can be defined by the generalized consensus specification. \par
\iffalse{\color{red} If this is already mentioned in the discussion section, remove from intro}
The approach of allowing the system to reorder operations may feel familiar to the reader, since it resembles how weak consistency models relax consistency guarantees to allow replicas to reorder operations \cite{Ladin1992}. By relaxing consistency and allowing operations to be reordered, these models reduce coordination requirements which results in decreased latency and better operation concurrency. However, relaxing consistency guarantees also introduces the chance of state divergence which can be tolerable or not depending on the application. These approaches are critical to geo-replicated scenarios where it's important to reduce round trips between data centers and maintaining strong consistency incurs in an unacceptable latency cost. \par\fi
Despite generalized consensus' potential, it's still an understudied problem and its formulation is rather complex and abstract which makes it hard to understand and reason about. This complexity also makes the algorithm hard to implement and adapt to different scenarios. There are several symptoms of this complexity. One of them is that only the original Generalized Paxos protocol exists for this problem and few works make use of it. Another consequence of the lack of knowledge about generalized consensus is that there are several potentially interesting research questions that researchers haven't answered. For instance, despite the connection between the commutativity observation that motivated generalized consensus and the reduced coordination requirements made possible by weak consistency, it is unclear how Generalized Paxos would function in geo-replicated scenarios where the goal is to minimize cross-datacenter round trips. Similarly, there is not much research on what effects the Byzantine assumption would have on the solution of the generalized consensus problem.
\par

\section{Contributions}
The goal of this work is to perform a thorough study of the generalized consensus problem to gain a deeper knowledge about the applicable protocols, such as Generalized Paxos, and how they behave in different scenarios. One of the greatest barriers in the comprehension and adoption of Generalized Paxos is the complexity of its description which, in turn, is caused by a very generic specification of consensus. Much in the same way that the clarification of the Paxos protocol contributed to its practical adoption, it's also important to simplify the description of Generalized Paxos. \par
Furthermore, we believe it's also relevant to extend this protocol to non-crash fault models, such as the Byzantine and the Visigoth fault models, since it will open the possibility of adopting Generalized Paxos in different scenarios. In particular, the Byzantine fault model has recently gained traction in the blockchain community given the rise in popularity of cryptocurrencies like Bitcoin~\cite{bitcoin}. The Visigoth fault model targets environments like datacenters where a large number of servers are connected through a network with high security barriers, which makes it both unlikely that multiple processes will act maliciously in a coordinated way and also likely that arbitrary behavior will stem from state corruption faults due to the sheer number of components in the datacenter~\cite{Porto2015}. In the Visigoth model fault and synchrony assumptions are parameterizable in order to allow for any amount of synchrony, ranging from full asynchrony to full synchrony, and any amount of Byzantine or crash faults, allowing the system to support any combination of faults within the spectrum between crash and Byzantine faults. This allows the system administrator to parameterize the model to fit the network's characteristics which are more likely to be predictable in a datacenter. This model allows us to study command history consensus from different perspectives and propose a solution that can solve this problem across a broad spectrum of system models. This is an important aspect because, although it adds complexity, it also adds the ability to develop a generic protocol that can be used in different environments. This can be seen as removing some generality in the problem specification while retaining the original motivating scenario while, at the same time, generalizing the fault model.
\par
Concretely, this work makes the following contributions:
\begin{itemize}
	\item A simplified version of generalized consensus, which preserves its motivating scenario of agreeing on command histories;
	\item a protocol derived from the Generalized Paxos protocol that solves the aforementioned consensus problem while improving the original protocol's understandability and ease of mapping into a code implementation;
	\item an extension of the Generalized Paxos protocol to the Byzantine model;
	\item a description of the Byzantine Generalized Paxos protocol that is more accessible than the original description, namely including pseudocode;
	\item a correctness proof for the Byzantine Generalized Paxos protocol;
	\item an extension of Generalized Paxos to the Visigoth model;
	\item a description of Visigoth Generalized Paxos complete with pseudocode to ease its translation into an actual implementaton;
	\item a correctness proof for the Visigoth Generalized Paxos protocol;
	\item a discussion of several extensions and optimizations to the previous protocols.
\end{itemize}

\iffalse
Therefore, as our first contribution, we simplify the problem specification from the full generalized consensus to a simpler specification that preserves the motivating scenario. Our simpler specification is similar to the consensus problem of command histories, where the goal is to agree upon sequences of commands that, when executed, result in the same state. Two histories don't have to contain the same commands in the same order to produce the same final state, it's sufficient to ensure that non-commutative operations are totally ordered. This means that commutative operations can be differently ordered without causing divergence in the state produced by executing the command histories. \par
In order to better understand how the generalized consensus problem can be used in different environments, we adapted Generalized Paxos to several models while still preserving the advantageous properties which motivated its creation. The \acrfull{cft} protocol starts by adapting the original protocol to the previously described command history problem. The second version of the protocol, \acrfull{bgp}, solves the same problem in the Byzantine fault model. In addition to the full consensus protocol, several contributions are proposed to extend and optimize \acrshort{bgp}. Namely, a checkpointing sub-protocol is proposed to manage the accumulation of data at the acceptors in a safe way and an optimization is proposed to reduce quorum requirements for certain sequences of commands at no additional cost. Lastly, the third version of the protocol, adapts Generalized Paxos to the Visigoth fault model \cite{Porto2015}, where the fault and synchrony assumptions are parameterizable in order to allow for any amount of synchrony, ranging from full asynchrony to full synchrony, and any amount of Byzantine or crash faults, allowing the system to support any combination of faults within the spectrum between crash and Byzantine faults. With this model we can study command history consensus from different perspectives and propose a solution that allows it to be solved across a broad spectrum of system models. This is an important aspect because, although it adds complexity, it also adds the ability to develop a generic protocol that can be used in different environments. As such, this work removes some generality of the problem specification while retaining the original motivating scenario but, in turn, generalizes the model, allowing the system administrator to tune the protocol.  One particularly interesting application is similar to that of weakly consistent systems and geo-replicated datacenters. By specifying a consensus problem akin to command histories, our protocol could take advantage of operation commutativity to minimize the number of ballots that incur in a higher coordination cost. In this scenario, the parameterizability of Visigoth model also plays an important role since we can specify a number of slow processes that allows us to reduce the number of replicas that are required to safely commit values. Another potentially interesting scenario, related to the fault model, could be one where we tolerate arbitrary, uncorrelated faults. This is an interesting scenario since it's enough to deal with arbitrary state corruption faults, which are common within datacenters \cite{AmazonS32}, but avoids the cost of dealing with coordinated Byzantine behavior.\par 
\fi

\section{Document outline}
The remainder of this document is structured as follows: Chapter \ref{Related Work} is divided in five subsections and surveys works that are related to our own and may provide relevant insights into the problem we're trying to solve. Each subsection describes scientific works in a specific area of interest to us. Chapter \ref{problem} has a mainly pedagogical purpose. It describes the original generalized consensus problem as well as components of Generalized Paxos that are vital for the functioning of the protocol but whose reasoning can be opaque to the reader. Chapter \ref{Crash Fault Model} describes a simplified version of generalized consensus and proposes a protocol to implement its solution. Extensions to the protocol are also discussed along with possible scenarios in which they may be helpful. Chapter \ref{Byzatine Fault Model} adapts the simplified consensus problem to the Byzantine fault model and presents its solution, \acrlong{bgp}. Similarly, to its counterpart in the crash fault model, we discuss extensions to the protocol as well as how it differs from the most similar protocol in the literature, \acrfull{fab}~\cite{Martin2006}. Chapter \ref{vft} uses the same consensus problem defined for the Byzantine fault model but makes use of the Visigoth model to adapt Byzantine Generalized Paxos to a model with parameterizable fault and synchrony assumptions. Both Chapter \ref{Byzatine Fault Model} and Chapter \ref{vft} also present correctness proofs for their respective protocols with respect to our proposed Byzantine command history problem. Chapter \ref{conclusion} concludes this work by discussing what was learned and what unexplored avenues of research are left for future work.
