\section{Model} \label{cft_model}

Before describe our consensus-solving protocol for the crash fault model, we must firs specify precisely what the consensus problem is and in which conditions the system will operate. We start by describing the fault and network in which the protocol will function.

\subsection{Network model}
For the CFT protocol, we consider an \emph{asynchronous} system in which a set of $N$ processes communicate by \emph{sending} and \emph{receiving} messages. There are three types of roles in the system, proposers, acceptors and learners, and each executes a specific algorithm. Informally, proposers provide input values that must be agreed upon by learners, the acceptors help the learners \emph{agree} on a value by issuing votes, and learners learn commands by appending them to a local sequence of commands to be executed, $learned_l$. Proposers can also distinguish themselves as the leader in order to help the system make progress. Each process can execute one or more roles without any interference between them. Our protocol requires a minimum number $N$ of acceptor processes and we assume that they have identifiers in the set $\{0,...,N-1\}$. In contrast, the number of proposer and learner processes can be set arbitrarily.

\subsection{Fault model}
The aforementioned minimum number $N$ of acceptor processes is a function of the maximum number of tolerated crash faults $f$, namely $N > 3f$. This condition implies that the system is able to function correctly despite up to $f$ crash faults. Quorums are defined as a set of $N-f$ processes which, in the usual case where $N$ is tight (i.e., $N=3f+1$), is equal to a quorum of $2f+1$. Note that in the traditional description of Fast and Generalized Paxos, $N$ is constrained by two conditions, namely $N>2f$ and $N>2e+f$, where $e$ is the number of faults tolerated by the system while allowing for fast ballots to take place. Similarly, Generalized Paxos' quorums are defined as $N-e$ and $N-f$ for fast and classic ballots, respectively. This implies that if we wish to always allow for fast executions then $e=f$ which means that $N>3f$ and both quorums are $2f+1$. The same reasoning applies to our CFT version of Generalized Paxos, but, since our goal is to simplify its description, we specialize the algorithm to the case where we always allow for fast executions (i.e., $e=f$). Therefore, in our protocol both fast and classic ballots can always be executed, as long as the system experiences only up $f$ faults, and the quorums are the same size in both cases.

\subsection{Problem statement}
In our simplified specification of Generalized Paxos, each learner $l$ maintains a monotonically increasing sequence of commands $learned_l$. We define two learned sequences of commands to be equivalent ($\thicksim$) if one can be transformed into the other by permuting the elements in a way such that the order of non-commutative pairs is preserved. A sequence $x$ is defined to be an \textit{eq-prefix} of another sequence $y$ ($x \sqsubseteq y$), if the subsequence of $y$ that contains all the elements in $x$ is equivalent ($\thicksim$) to $x$. We present the requirements for this consensus problem, stated in terms of learned sequences of commands for a correct learner $l$, $learned_l$. To simplify the original specification, instead of using c-structs (as explained in Section~\ref{Related Work}), we specialize to agreeing on equivalent sequences of commands:

\begin{enumerate}
	\item \textbf{Nontriviality.} $learned_l$ can only contain proposed commands. 
	\item \textbf{Stability.} If $learned_l = v$ then, at all later times, $v \sqsubseteq learned_l$, for any $l$ and $v$. 
	\item \textbf{Consistency.}  At any time and for any two learners $l_i$ and $l_j$, $learned_{l_i}$ and $learned_{l_j}$ can subsequently be extended to equivalent sequences.
	\item \textbf{Liveness.} For any proposal $s$ from a proposer, and learner $l$, eventually $learned_l$ contains $s$.
\end{enumerate}
