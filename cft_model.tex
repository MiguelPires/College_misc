\section{Model} \label{cft_model}

Before describing our consensus-solving protocol for the crash fault tolerant model (\acrshort{cft}), we must first specify precisely our simplified consensus problem and in which conditions the system will operate. We start by describing the fault and network models in which the protocol will function before defining the consensus problem's requirements.

\subsection{Network Model}
For the crash fault tolerant protocol, we consider an \emph{asynchronous} system in which a set of $N$ processes communicate by \emph{sending} and \emph{receiving} messages. For simplicity, we assume perfect links~\cite{cgr:book}, where a message that is sent by a non-faulty sender is eventually received exactly once and any message delivered by a process $q$ with sender $p$ was previously sent to $q$ by process $p$ (such links can be implemented trivially using retransmission and elimination of duplicates~\cite{cgr:book}). There are three types of roles in the system: proposers, acceptors and learners, and each executes a specific algorithm. Informally, proposers provide input values that must be agreed upon by learners, the acceptors help the learners \emph{agree} on a value by issuing votes, and learners learn commands by appending them to a local sequence of commands to be executed, $learned_l$. Proposers can also distinguish themselves as the leader in order to help the system make progress. Each process can execute one or more roles without any interference between them. Our protocol requires a minimum number $N$ of acceptor processes and we assume that they have identifiers in the set $\{0,...,N-1\}$. In contrast, the number of proposer and learner processes can be set arbitrarily.

\subsection{Fault Model}
The aforementioned minimum number $N$ of acceptor processes is a function of the maximum number of tolerated crash faults $f$, namely $N > 3f$. This condition implies that the system is able to function correctly despite up to $f$ crash faults. A \textit{correct} process is one that eventually executes the actions in the algorithms assigned to it, such as sending and receiving messages. Quorums are defined as a set of $N-f$ processes which, in the usual case where $N$ is tight (i.e., $N=3f+1$), is equal to a quorum of $2f+1$. Note that in the traditional description of both Fast and Generalized Paxos, $N$ is constrained by two conditions, namely $N>2f$ and $N>2e+f$, where $e$ is the number of faults tolerated by the system while allowing for fast ballots to take place~\cite{Lamport2006,Lamport2005}. Similarly, Generalized Paxos' quorums are defined as $N-e$ and $N-f$ for fast and classic ballots, respectively. This implies that if we wish to always allow for fast executions then $e=f$ which means that $N>3f$ and both quorums are $2f+1$. The same reasoning applies to our \acrshort{cft} version of Generalized Paxos, but, since our goal is to simplify its description, we specialize the algorithm to the case where we always allow for fast executions (i.e., $e=f$). Therefore, in our protocol both fast and classic ballots can always be executed, as long as the system experiences only up $f$ faults, and the quorums are the same size in both cases.

\subsection{Problem Statement} \label{cft_problem}
In our simplified specification of Generalized Paxos, each learner $l$ maintains a monotonically increasing sequence of commands $learned_l$. We define two learned sequences of commands to be equivalent ($\thicksim$) if one can be transformed into the other by permuting the elements in a way such that the order of non-commutative pairs is preserved. A sequence $x$ is defined to be a \textit{prefix} of another sequence $y$ ($x \sqsubseteq y$), if the subsequence of $y$ that contains all the elements in $x$ is equivalent ($\thicksim$) to $x$. In this case, a prefix is not a strict prefix because a sequence is considered to be a prefix of itself. We present the requirements for this consensus problem, stated in terms of learned sequences of commands for a correct learner $l$, $learned_l$. To simplify the original specification, instead of using \textit{c-structs} (as explained in Section~\ref{Related Work}), we specialize to agreeing on equivalent sequences of commands:

\begin{enumerate}
	\item \textbf{Nontriviality.} $learned_l$ can only contain proposed commands. 
	\item \textbf{Stability.} If $learned_l = v$ then, at all later times, $v \sqsubseteq learned_l$, for any $l$ and $v$. 
	\item \textbf{Consistency.}  At any time and for any two learners $l_i$ and $l_j$, $learned_{l_i}$ and $learned_{l_j}$ can subsequently be extended to equivalent sequences.
	\item \textbf{Liveness.} For any proposal $s$ from a proposer, and learner $l$, eventually $learned_l$ contains $s$.
\end{enumerate}
