\subsection{Description}
We now present the adapted Generalized Paxos protocol for a Byzantine adversary.\par
\textbf{View Change} The goal of the view change sub-protocol is to ensure that when $f+1$ processes suspect the leader to be faulty all correct processes commit to a new view and stop participating in lower-numbered views. To this end, processes can multicast suspicion messages if they believe that the leader is faulty. Suspicions contain the current view number, signed by the sending process in a verifiable way. This signature is the digest of sender's identification and current view number, encrypted by the suspecting process's private key. If a correct process receives $f+1$ suspicions, it stops participating in the previous view and multicasts a view-change message. View-change messages contain a ballot number, the previously committed ballot and value, and the $f+1$ suspicions, including the signature. If a process receives a view-change message without previously receiving $f+1$ suspicions, it can verify the suspicions, commits to the new view and multicasts a view-change message. The signature allows a process that receives this message to commit to the new view and multicast its own view-change messages without receiving $f+1$ suspicions itself. The process must only confirm that the signatures are valid and correspond to suspicions sent by distinct processes for the current view. This guarantees that if one correct process received the $f+1$ suspicions and broadcasted the view-change message, then all correct processes will receive that message, validate the proof of $f+1$ suspicions and switch to the new view. Processes start participating in the new view as soon as they broadcast their view-change messages, since the multicast of one correct view-change message is all it takes to ensure that all correct process will eventually switch to the new view. The only process that must wait for $2f+1$ view-change messages is the leader of the new view since, to send new sequences, it needs to know the values voted for in the last ballot for a quorum of acceptors. \par
\textbf{View Change Proof} We can prove that $f+1$ suspicions trigger a new view successfully since as soon as one process receives those suspicions it will broadcast a view-change message containing a proof that $f+1$ processes suspect the leader. When other processes receive either the $f+1$ suspicions or the view-change message, they will broadcast their own view-change messages and start participating in the new view. Faulty processes alone can't force a new view since $f+1$ suspicions are required for any correct process to commit to the new view.\par
\textbf{Agreement Protocol} The consensus protocol allows processes to agree on equivalent sequences of commands. Each consensus instance is called a ballot, which can be \textit{classic} or \textit{fast}. In classic ballots, a leader proposes a single sequence of commands which is learned by the learners. In fast ballots, multiple proposers can concurrently propose single commands to acceptors which send their votes to learners. Concurrency implies that acceptors may send votes in different orders but the protocol ensures that, as long as the resulting sequences are equivalent, the commands will be learned in two message delays. A classic ballot in Generalized Paxos contains a first phase where the leader obtains a promise that the acceptors will not participate in lower-numbered ballots and the sequence that the acceptor voted for. This first phase becomes unnecessary when a classic ballot is executed after the view change, since the leader already gathered the last committed sequences and no promise is required from the acceptors. The leader doesn't need to ask the acceptors not to participate in lower-numbered ballots because, for the remainder of the current view, the leader is the only process that can start a new ballot. \todo{Is there any problem if an acceptor receives an accept message out-of-order? I believe not} However, the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot, since the acceptors may have voted for new sequences. \par
\textbf{Classic Ballots} In a classic ballot, proposers send their proposed commands to the leader who sends a single sequence of commands to the acceptors. This sequence is built by appending the new proposals to the only sequence that may have been committed in the previous ballot, if any such sequence exists. The leader starts by sending phase 1a messages to acceptors, which respond with the last value for which they have voted for. If, among the reported values, there are multiple non-commutative sequences then at most one of them was learned. In order for the leader to pick the committed sequence, he must gather $x$ phase 1b messages for that value. We define $x$ as the number of votes for a certain sequence $v$ that the leader must see in order to be sure that no sequence other than $v$ may have been learned. The reasoning for the derivation of this quantity is the following: the leader must see a certain amount of votes $x$ for a sequence $v$ such that the remaining acceptors $N-x$ are not enough to form a fast quorum $N-E$ for any sequence other than $v$. More formally: 
\begin{gather*} \\
N - x < Q_f \label{eq_1} \tag{1} \\ 
N - x < N - E \label{eq_2} \tag{2} \\
-x < -E \label{eq_3} \tag{3} \\
x > E \label{eq_4} \tag{4} \\
\end{gather*}

Lamport defines $E$ as the number of acceptors that can fail while still allowing a fast round to succeed \cite{L06}. With the minimum $E$ of $\lfloor\frac{N}{4}\rfloor$ and implicitly a fast quorum size of $\frac{3N}{4}$, $x$ would become:
\begin{gather*} \\
N - x < Q_f \label{eq_1} \tag{1} \\ 
N - x < \lceil\frac{3N}{4}\rceil \label{eq_2} \tag{2} \\
3f+1 - x < \frac{3*(3f+1)}{4} \label{eq_3} \tag{3} \\
12f+4 -4x < 9f+3 \label{eq_4} \tag{4} \\ 
3f+1 < 4x \label{eq_5} \tag{5} \\ 
x > \frac{3f+1}{4} \label{eq_6} \tag{6} \\ 
\end{gather*}

This is coherent with the more generic expression of $x > E$ since, with $E = \lfloor\frac{N}{4}\rfloor$ and $N = 3f+1$, we arrive at the same result: 
\begin{gather*} \\
x > E  \\
x > \lfloor\frac{N}{4}\rfloor \\
x >\frac{3f+1}{4}\\
\end{gather*}

\todo{What if some acceptors only receive some of the commands in a fast ballot and then reject the leader's sequence because it's not an extension?}

However, since the system is operating under the Byzantine assumption, we must gather $x+f$ reports in order to be sure that $x$ correct acceptors actually sent those votes. So the leader must gather more than $E+f$ votes for a given sequence. Also note that even if the leader gathered $E+f$ votes for a sequence $v$, this doesn't mean that $v$ was learned. However, since it means that no other sequence may have been learned, we can safely incorporate it in the new sequence without violating any property. If we assume a system of $N = 3f+1$ then, since $N > 2E+f$, $E$ becomes its maximum value, $f$. In such a system, gathering more than $E+f$ simply becomes gathering a classic quorum of $2f+1$ replies even for fast ballots.\par
When a leader gathers the state, $f$ faulty acceptors can report incorrect values and other $f$ acceptors can report correct but out of date sequences. In such a scenario, only one acceptor would respond with a correct and updated sequence which isn't sufficient to form a quorum. For the leader to successfully read the state, he must gather a quorum of equivalent sequences. If the system is synchronous and a quorum of correct acceptors reply, the leader can calculate which sequence to extend by selecting the only sequence which has more than $E+f$ votes. The leader sends the sequence to the acceptors which, in turn, send it to the learners. The learners verify that the new sequence is an extension of the previously learned value, to avoid violating the stability property. After receiving $N-f$ messages, the learners learn the value present in at least $f+1$ messages. \par
\textbf{Fast Ballots} To initiate a fast ballot, the leader broadcasts an \textit{any} value to inform proposers that they may propose directly to the acceptors. Proposals are sent in the form of a single command to be appended to the command history. These proposals are sent to the acceptors that send their votes to the learners. To learn a proposal, a learner must receive $N-E$ votes. However, since non-commutative commands may be concurrently proposed, a verification round is needed to ensure that conflicting commands aren't learned by different learners in different orders. To this end, after receiving $N-E$ messages from acceptors, a learner broadcasts a verification message to the other learners. A learner only responds to a verification request after receiving it from more than $f$ learners since less than that would allow Byzantine learners to prevent conflicting commands from being committed. When a learner receives more than $f$ requests for verification of a certain command and it commutes with every other value learned in the same fast ballot, the learner broadcasts an acknowledgment that the value is safe to be learned. Upon receiving more than $2f$ acknowledgments to a verification request, a learner can safely learn the sequence. If a proposed command is non-commutative with an already learned command and some learner tries to learn it, at least one correct learner that has acknowledged the first non-commutative value will notice the conflict and ignore the request. Therefore, only one of two non-commutative proposals can be learned in each ballot. \par
\textbf{Verification Round Proof} The verification round ensures the consistency property by preventing learners from learning conflicting commands in different orders. For two learners to learn conflicting commands, they would both have to receive an acknowledgment from a correct learner. However, since a correct learner can only learn after receiving $N-f$ acknowledgments to his verification request and no correct learner would send an acknowledgment to two non-commutative commands, one of the values can receive at most $2f$ acknowledgments ($f$ byzantine learners and $f$ that may not have seen the previous command) which isn't enough to learn the command.\par