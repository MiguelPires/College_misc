\section{Byzantine Fault Model} \label{Byzatine Fault Model}
%\subsection{Description}
This section presents our Byzantine fault tolerant Generalized Paxos
Protocol (or BGP, for short). This description includes both modifications due to the simplification of the generalized consensus problem and its extension to the Byzantine model. During the development of this protocol, we tried to preserve the original protocol structure and message pattern both to preserve the original common case performance and to keep it as familiar as possible to the reader. This resulted in a protocol that is similar to the original Generalized Paxos protocol and doesn't include any additional phases. For this reason, we will refrain from fully describing its execution in detail and will focus on the novel aspects of BGP and why they are  necessary.

\subsection{Overview}

We modularize our protocol explanation according to the following main components, which are also present in other protocols of the Paxos family:

\begin{itemize}
	
	\item
	{\bf View change} -- The goal of this subprotocol is to ensure that, at any given moment, one of the proposers is chosen as a distinguished leader, who runs a specific version of the agreement subprotocol. To achieve this, the view change subprotocol continuously replaces leaders, until one is found that can ensure progress (i.e., commands are eventually appended to the current sequence).
	
	\item
	{\bf Agreement} -- Given a fixed leader, this subprotocol extends the current sequence with a new command or set of commands. Analogously to Fast Paxos~\cite{L06} and Generalized Paxos~\cite{Lamport2005}, choosing this extension can be done through two variants of the protocol: using either {\bf classic ballots} or {\bf fast ballots}, with the characteristic that fast ballots complete in fewer communication steps, but may have to fall back to using a classic ballot when there is contention among concurrent requests.
	
\end{itemize}

\subsection{View change} 

The goal of the view change subprotocol is to elect a distinguished acceptor process, called the leader, that carries through the agreement protocol, i.e., enables proposed commands to eventually be learned by all the learners. The overall design of this subprotocol is similar to the corresponding part of existing BFT state machine replication protocols~\cite{CL99}.

In this subprotocol, the system moves through sequentially numbered views, and the leader for each view is chosen in a rotating fashion using the simple equation $\textit{leader(view)}=\textit{view mod N}$. The basic idea of this subprotocol is that acceptor processes monitor whether progress is being made on adding commands to the current sequence, and, if not, they send a message to other acceptors suspecting the current leader. If enough suspicions are collected, processes can move to the subsequent view.

In more detail, whenever an acceptor process individually perceives that liveness is not being upheld (i.e., there are pending commands that have not gathered enough support to conclude their execution, as detailed next), it starts suspecting the leader and multicasts a signed {\sc suspicion} message for the current view to all acceptors.

To ensure that $f$ Byzantine processes cannot trigger view changes by producing  false suspicions, acceptor processes only send a view change message indicating their commitment to starting a new view after hearing that $f+1$ processes suspect the leader to be faulty. In particular, at this point, acceptor processes multicast a view-change message containing the new view number, the $f+1$ signed suspicions, and signed proof that the acceptor sent the view-change message for the new view number. If a process receives a view-change message without previously receiving $f+1$ suspicions, it can also multicast a view-change message, after verifying that the suspicions are correctly signed by $f+1$ distinct processes.
This guarantees that if one correct process receives the $f+1$ suspicions and broadcasts the view-change message, then all correct processes, upon receiving this message, will be able to validate the proof of $f+1$ suspicions and also multicast the view-change message.

Finally, an acceptor process must wait for $N-f$ view-change messages to start participating in the new view (i.e., update its view number and the corresponding leader process). At this point, the acceptor also assembles the $N-f$ view-change messages proving that others are committing to the new view, and sends them to the new leader. This allows the new leader to start its leadership role in the new view once it validates the $N-f$ signatures contained in a single acceptor's message.

\subsection{Agreement protocol} 

The consensus protocol allows learner processes to agree on equivalent sequences of commands (according to our previous definition of equivalence).
As was the case in the revised CFT protocol, the purpose of this algorithm is to extend a learned sequence of commands in order to make possible the implementation of state machine replication across a set of learner processes. These extensions are performed through a series of instances of consensus, ballots, which can either be \textit{classic} or \textit{fast}. The message pattern in BGP is the same as in the previous protocols, with only sporadic changes due to the presence of Byzantine failures. The gathered quorums in this protocol are described as $N-f$ which, if the minimum system size of $N=3f+1$ is chosen, corresponds to a quorum $2f+1$ replicas (i.e., a Byzantine quorum).
We now briefly described each type of ballot, pointing out places where it departs from the revised CFT specification.

\subsubsection{Classic ballots} 

Classic ballots in this protocol work in a way that is very close to the original Paxos protocol~\cite{Lam98}. 
The leader continuously collects proposals by assembling commands received from the proposers in a sequence. 
When the next ballot is triggered, the leader starts by sending phase $1a$ messages to all acceptors with just the current ballot number. After receiving this message, the acceptors reply with a phase $1b$ message to the leader, containing every stored sequence of commands they voted for. Both in classic Paxos and in our revised CFT version, the phase $1b$ messages from the acceptors also carry a promise not to participate in lower-numbered ballots, in order to prevent safety violations~\cite{Lam98}.  However, in BGP this promise is already implicit, given (1) there is only one leader per view and it's the only process allowed to propose in a classic ballot and (2) acceptors replying to that message must be in the same view as that leader.\par

Upon receiving phase $1b$ messages, the leader validates that the commands were proposed by actual proposers by validating command signatures. This is necessary because otherwise Byzantine acceptors could fabricate proposals, violating the non-triviality. After gathering a quorum of $N-f$ responses, the leader initiates phase $2a$ by sending a message with a proposal to the acceptors, who respond to the message by sending phase $2b$ messages to the learners, containing the ballot and the proposal from the leader. After receiving $N-f$ votes for a sequence, a learner learns it by extracting the commands that are not contained in his $learned$ sequence and appending them in order. 

\subsubsection{Fast ballots} 

Similarly to previous descriptions of the Generalized Paxos protocols, fast ballots are able to leverage the weaker specification of generalized consensus to allow for the faster learning of commands in two message steps.
As previously mentioned, the basic message pattern in BGP remains altered despite the stronger fault model. However, since new fault scenarios are possible, it's useful to analyze what happens when arbitrary and possible correlated faults occur. Besides conflicts generated by concurrent proposals, Byzantine acceptors can also vote for different sequences to different learners, with the goal of making them learn different sequences, violating consistency. The worst case scenario occurs when non-commutative commands are concurrently proposed such that the acceptors' vote is split and at the same time $f$ Byzantine acceptors aware of this situation try to exploit the conflict. In this case, $f$ Byzantine acceptors each vote for two non-commutative sequences at different learners and, due to the concurrent nature of the proposals, $f$ correct acceptors vote for each of the sequences. At this point, both conflicting values have $2f$ apparently valid votes and only acceptor hasn't voted. Since this acceptor is correct, only one of the sequences can receive the last remaining vote. It's important to note that the authenticated model is used and, therefore, processes can't be impersonated by others.
 
\subsection{Checkpointing} BGP includes an additional feature that allows the leader to propose a special command $C^*$ that causes both the acceptors and learners to safely discard previously stored commands. This feature can be used to prevent commands from being stored indefinitely. However, since commands are kept at the acceptors to ensure that they will eventually be committed, special care has to be taken before discarding them. To prevent unlearned commands from being discarded, the checkpointing command must be sent within a sequence in a classic ballot. In phase 1 of that classic ballot, acceptors send every command they have to the leader, who waits for $N-f$ phase 1b messages. The leader can be sure that the commands were originated from proposers by verifying the signatures they contain. Since, when proposing to acceptors in fast ballots, proposers wait for acknowledgments from $N-f$ proposers, there's at least one correct acceptor in the intersection of a quorum that received a proposal and a quorum that sends commands to the leader. This means that any proposed value will be sent by some acceptor to the leader and included in the leader's sequence, along with the checkpointing command. Since acceptors must be certain that it's safe to discard previously stored commands, before sending phase 2b messages to learners, they first broadcast these messages among themselves. This round between acceptors is necessary because a Byzantine leader could send a checkpointing command to some acceptors but not others. After waiting for $N-f$ such messages, acceptors send phase 2b messages to the learners along with the cryptographic proofs exchanged in the acceptor-to-acceptor broadcast. After receiving just one message, the leader may simply validate the $N-f$ acceptor proofs contained in it and learn the commands. The learners discard previously stored state when they execute the checkpointing command.
\input{discussion}