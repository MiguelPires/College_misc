%\subsection{Description}
This section presents our Byzantine fault tolerant Generalized Paxos
Protocol. Given our space constraints, we opted for merging in a
single description a novel presentation of Generalized Paxos and its
extension to the Byzantine model. Then, in Appendix~\ref{app:cft}, we
present the crash-fault-tolerant version of Generalized Paxos,
following the same notation and pseudo-code description we use here.

\subsection{Overview}

We modularize our protocol explanation according to the following main components, which are also present in other Paxos-related protocols:

\begin{itemize}

\item
{\bf View change} -- The protocol that continuously replaces leaders, until one is found that can ensure progress (i.e., commands are eventually executed).

\item
{\bf Agreement} -- Given a fixed leader, this protocol extends the current sequence with a new command or set of commands. Analogously to Fast Paxos~\cite{fast:paxos} and Generalized Paxos~\cite{generalized:paxos}, choosing this extension can be done using two different sub-protocols: using either {\bf classic ballots} or {\bf fast ballots}, with the characteristic that fast ballots complete in fewer communication steps, but may have to fall back to using a classic ballot when there is contention among concurrent requests.

\end{itemize}

\subsection{View change} 

The goal of the view change sub-protocol is to elect a leader that is able to carry through the agreement protocol, i.e., that enables proposed commands to eventually be learned by all the learners.

To allow this, whenever a subset of correct processes perceive that liveness is not being upheld, this must be sufficient for triggering a view change. However, even if a threshold of up to $f$ Byzantine processes produce false suspicions, this should not suffice to trigger a view change. Therefore, this mechanism must ensure that when $f+1$ processes suspect the leader to be faulty, and only then all correct processes commit to a new view and stop participating in lower-numbered views. In particular, processes start broadcasting suspicion messages if they believe that the leader is faulty. Suspicions contain the current view number, and are signed by the sending process, to avoid being forged. Furthermore, to ensure that views change succeed if they have enough support but cannot be triggered by Byzantine processes, if a correct process receives $f+1$ suspicions, it stops participating in the previous view and multicasts a view-change message. View-change messages contain a ballot number, the previously committed ballot and value, and the $f+1$ signed suspicions. If a process receives a view-change message without previously receiving $f+1$ suspicions, it will verify the suspicions by validating they are signed by $f+1$ distinct processes, commit to the new view and multicast a view-change message. (As such, the signatures allow a process that receives this message to commit to the new view and multicast its own view-change messages without receiving $f+1$ suspicions itself.)  This guarantees that if one correct process receives the $f+1$ suspicions and broadcasts the view-change message, then all correct processes, upon receving this message, will be able to validate the proof of $f+1$ suspicions and switch to the new view. Processes start participating in the new view as soon as they broadcast their view-change messages, since the multicast of one correct view-change message is all it takes to ensure that all correct process will eventually switch to the new view. The only process that must wait for $2f+1$ view-change messages is the leader of the new view since, to send new sequences, it needs to know the values voted for in the last ballot for a quorum of acceptors, as described next.



%\textbf{View Change Proof} We can prove that $f+1$ suspicions trigger a new view successfully since as soon as one process receives those suspicions it will broadcast a view-change message containing a proof that $f+1$ processes suspect the leader. When other processes receive either the $f+1$ suspicions or the view-change message, they will broadcast their own view-change messages and start participating in the new view. Faulty processes alone can't force a new view since $f+1$ suspicions are required for any correct process to commit to the new view.\par

\subsection{Agreement protocol} 

The consensus protocol allows processes to agree on equivalent sequences of commands (according to our previous definition of equivalence). Each consensus instance is called a ballot, which can be \textit{classic} or \textit{fast}. 

In classic ballots, a leader proposes a single sequence of commands, which is learned by the learners. 
A classic ballot in Generalized Paxos follows a protocol that is very similar to the one used by classic Paxos~\cite{paxos}. This protocol comprises a first phase where the leader obtains a promise that the acceptors will not participate in lower-numbered ballots, and each acceptor conveys to the leader the sequence that the acceptor has already voted for. This first phase becomes unnecessary when a classic ballot is executed after a view change, since the view change protocol can include this first phase, i.e., it can gather the last committed sequences and extract that same promise from the acceptors. This promise is implicitly valid because, for the remainder of the current view, the leader is the only process that can start a new ballot. \todo{Can we replace the last two sentences with something simpler, e.g.: ``The first phase can be run only once for an entire view, by extracting a promise that, for the remainder of the current view, the leader is the only process that can start a new ballot.''} This is followed by a second phase where the leader picks \todo{insert a short description of the second phase...}

In fast ballots, multiple proposers can concurrently propose either single commands or sequences of commands (by sending them directly to the acceptors), and eventually a set of equivalent sequences must be learned by the learners. We use the term \textit{proposal} to denote either the command or sequence of commands that was proposed.
Concurrency implies that acceptors may send votes in different orders but the protocol ensures that, as long as the resulting sequences are equivalent, the commands will be learned in two message delays. 

\todo{Should we move this paragraph to the end of the section?} Note that there is a subtle interplay between the two types of ballots, since the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot. This is because the acceptors may have used a fast round to vote for new sequences that are unknown to the leader, since they were proposed directly by the proposers.

Next, we present the protocol for each type of ballot in detail.

\subsection{Classic ballots} 

In a classic ballot, proposers send their proposed commands to the leader who sends a single sequence of commands to the acceptors. This sequence is built by appending the new proposals to the longest sequence committed in the previous ballot \todo{not really the longest?}. The leader starts by sending phase $1a$ messages to all acceptors, which respond with the last ballot in which they voted, the sequence of commands they voted for.
% and cryptographic signatures of $N-f$ acceptors for each accepted proposal included in the sequence. 
(We defer the discussion of how this sequence is determined and how a new proposal is correspondingly assembled by the leader until we have described fast ballots.) After assembling the proposal, the leader initiates phase $2a$ by sending a message with the proposal to the acceptors. Upon receiving the proposal, the acceptor computes a cryptographic proof, verifiable by any acceptor, that it will vote for the proposal in the current ballot. This proof is signing the pair $\langle ballot,value \rangle$ with the acceptor's private key. After computing the digital signature, the acceptor broadcasts it along with the ballot and value to the other acceptors. Every acceptor waits for $N-f$ such messages that contain correct signatures for the same ballot and proposal. After a quorum of verification messages has been reached, the acceptor sends a phase $2b$ message to the learners, containing the ballot, the proposal and the certificates proving that $N-f$ vote for the same value. By sending these proofs, a learner only needs to receive a phase $2b$ message from a single acceptor to know that a quorum of acceptor has voted for it and every learner will learn it. \par

\subsection{Fast ballots} 

To initiate a fast ballot, the leader informs both proposers and acceptors that the proposals may be sent directly to the acceptors. Unlike classic ballots, where a leader's proposed sequence consists of commands sent by the proposers appended to the sequence of already learned commands, in a fast ballot, proposals can be sent to the acceptors in the form of either a single command or a sequence to be appended to the command history. These proposals are sent directly from the proposers to the acceptors which verify that each commands commutes with every other command proposed on the same ballot. If no conflict is detected, the acceptor computes a signature that proves his intent to vote for the proposal and broadcasts it to all acceptors. Upon receiving such a verification message, an acceptor verifies the proof, checks if the proposal commutes with every other command proposed in the same ballot and, after receiving $N-f$ such messages, it sends a phase $2b$ message to the learners. The command must be checked for commutativity with the other known proposals both before sending and after receiving a verification message because, not only can an acceptor receive a command that is non-commutative with some other command it may have been previously received, but also it may receive the verification messages of $N-f$ acceptors before actually receiving the proposal itself. This ensures that no two non-commutative commands are accepted in the same ballot and, therefore, the learned sequences are equivalent. However, in the case that two non-commutative proposals are concurrently received, it's possible that neither one of them is accepted. Like in the classic ballot, the phase $2b$ message sent to the learners contains the current ballot number, the proposed command and the $N-f$ certificates proving that $N-f$ acceptors agreed to vote for it. Since the proofs are sent along with the proposal, a learner only needs to receive one phase $2b$ message and verify the cryptographic signatures before learning the command.\par
\textbf{Verification Round Proof} 
The additional broadcast round between acceptors assures us of two things: (1) A correct acceptor only sends its vote to the learners after being able to prove to another process that $N-f$ acceptors voted for the proposal; (2) A correct acceptor only sends its vote to the learners when $N-f$ acceptors have agreed that the proposed command commutes with every other proposal received in the same ballot. Therefore, the command can be learned without any chance of consistency being violated. If the acceptor sent non-commutative commands in phase $2b$ messages to the learners, the messages could be reordered while in-transit and end up being learned in different orders at different learners. If non-commutative commands are not totally ordered then the consistency would be violated and consensus wouldn't be reached. \par
\textbf{Leader Value Picking} Previously, we postponed the discussion of how the leader picks a sequence because it is influenced by the verification round. To build a proposal the leader must wait for $N-f$ phase $1b$ messages containing a set of values accepted by the acceptor in the last ballot and certificates for those values. The leader rebuilds the sequence that the acceptor voted for by verifying each of the $N-f$ proofs for each proposal and appending them to a sequence. When the leader contains $N-f$ such sequences, it is guaranteed to know about any proposal that may have been accepted in the previous ballot. Before sending its own proposal, the leader goes through the sequences assembled for each acceptor, building a sequence that is safe to extend by extracting every command from those sequences and appending it to the safe sequence exactly once. To avoid appending the same command more than once, commands must be uniquely identified. This can be done through the proposer's id and a sequence id, $\langle p_{id}, seq_{id}\rangle$. After going through $N-f$ accepted sequences, the resulting safe sequence contains every proposal learned in the previous ballot and can be safely extended with the leader's proposals without breaking stability.
