\section{Crash Fault Model} \label{Crash Fault Model}

This section describes the crash fault tolerant version of the Generalized Paxos protocol for our simplified problem. The only modifications applied to the protocol were made to make it simpler while still ensuring its correctness. The protocol should still be recognizable as Generalized Paxos since its message pattern and control flow remain the same. However, we chose to describe it in detail, both in the interest of clarity and also so that in the description of later iterations of the protocol we can focus on the aspects that differ. 

\subsection{Agreement protocol} 

The consensus protocol allows learner processes to agree on equivalent sequences of commands (according to our previous definition of equivalence).
An important conceptual distinction between the original Paxos protocol and Generalized Paxos is that, in the original Paxos, each instance of consensus is called a ballot and agrees upon a single value, whereas in Generalized Paxos, instead of being separate instances of consensus, ballots correspond to an extension to the sequence of learned commands of a single ongoing consensus instance.
In both protocols, ballots can either be \textit{classic} or \textit{fast}. \par

In classic ballots, a leader proposes a single sequence of commands, such that it can be appended to the commands learned by the learners. 
A classic ballot in Generalized Paxos follows a protocol that is very similar to the one used by classic Paxos~\cite{Lam98}. This protocol comprises a first phase where each acceptor conveys to the leader the sequences that the acceptor has already voted for (so that the leader can resend commands that may not have gathered enough votes).
This is followed by a second phase where the leader picks an extension to the sequence of previously proposed commands and broadcasts it to the acceptors. The acceptors send their votes to the learners, who then, after gathering enough support for a given extension to the current sequence, append the new commands to their own sequences of learned commands and discard the already learned ones.\par

In fast ballots, multiple proposers can concurrently propose either single commands or sequences of commands by sending them directly to the acceptors. (We use the term \textit{proposal} to denote either the command or sequence of commands that was proposed.)
In this case, concurrency implies that acceptors may receive proposals in a different order. If the resulting sequences are equivalent, then the fast ballots are successfully learned in two message delays. If not, the protocol must fall back to using a classic ballot.

Next, we present the protocol for each type of ballot in detail.

\subsection{Classic ballots} 

Classic ballots work in a way that is very similar to the original Paxos protocol~\cite{Lam98}. Therefore, throughout our description, we will highlight the points where Generalized Paxos departs from the original protocol, in particular where it's due to behaviors caused by our simplified specification of Generalized Paxos.

In this part of the protocol, the leader continuously collects proposals by assembling commands received from the proposers in a sequence. This sequence is built by appending arriving proposals to a sequence containing every proposal received since the previous ballot. (This differs from classic Paxos, where it suffices to keep a single proposed value that the leader attempts to reach agreement on.)

When the next ballot is triggered, the leader starts the first phase by sending phase $1a$ messages to all acceptors containing just the ballot number. Similarly to classic Paxos, acceptors reply with a phase $1b$ message to the leader, which reports all sequences of commands they voted for. This message also carries a promise not to participate in lower-numbered ballots, in order to prevent safety violations~\cite{Lam98}.

After gathering a quorum of $N-f$ phase $1b$ messages, the leader initiates phase $2a$ by sending a message with a proposal to the acceptors. This proposal is assembled by appending the sequences gathered from the proposers to a sequence that contains every command in the sequences that were previously accepted by the acceptors in the quorum (instead of sending a single value with the highest ballot number in the classic specification).

The acceptors reply to phase $2a$ messages by sending phase $2b$ messages to the learners, containing the ballot and the proposal from the leader. After receiving $N-f$ votes for a sequence, a learner learns it by extracting the commands that are not contained in his $learned$ sequence and appending them in order. Note that for a sequence to be learned, a learner doesn't have to receive $N-f$ votes for the exact same sequence but for equivalence sequences (in accordance to our previous definition of equivalence).

\subsection{Fast ballots} 

In contrast to classic ballots, fast ballots are able to leverage a weaker specification of generalized consensus, in terms of command ordering at different replicas, to allow for faster execution of commands in some cases.

The basic idea of fast ballots is that proposers contact the acceptors directly, bypassing the leader, and then the acceptors send their votes on proposals to the learners. If a learner can gather $N-f$ votes for a sequence (or an equivalent one), then it is learned. If, however, a conflict exists between sequences then they will not be considered equivalent and at most one of them will gather enough votes to be learned. Conflicts are dealt with by maintaining the proposals at the acceptors so they can be sent to the leader and learned in the next classic ballot. This differs from Fast Paxos where recovery is performed through an additional round-trip. \par
Next, we explain each of these steps in more detail.


\noindent {\bf Step 1: Proposer to acceptors.}
To initiate a fast ballot, the leader informs both proposers and acceptors that the proposals may be sent directly to the acceptors. Unlike classic ballots, where the sequence proposed by the leader consists of the commands received from the proposers appended to previously proposed commands, in a fast ballot proposals can be sent to the acceptors in the form of either a single command or a sequence to be appended to the command history. These proposals are sent directly from the proposers to the acceptors.

\noindent {\bf Step 2: Acceptors to learners.}
Acceptors append the proposals they receive to the proposals they have previously accepted in the current ballot and broadcast the result to the learners. Similarly to what happens in classic ballots, the fast ballot equivalent of the phase $2b$ message, which is sent from acceptors to learners, contains the current ballot number and the command sequence. However, since commands (or sequences of commands) are concurrently proposed, acceptors can receive and vote for non-commutative proposals in different orders. To ensure safety, correct learners must learn non-commutative commands in a total order. To this end, a learner must gather $N-f$ votes for equivalent sequences. That is, sequences do not necessarily have to be equal in order to be learned since commutative commands may be reordered. Recall that a sequence is equivalent to another if it can be transformed into the second one by reordering its elements without changing the order of any pair of non-commutative commands. (Note that, in the pseudocode, equivalent sequences are being treated as belonging to the same index of the \emph{messages} variable, to simplify the presentation.) By requiring $N-f$ votes for a sequence of commands, we ensure that, given two sequences where non-commutative commands are differently ordered, only one sequence will receive enough votes. {\color{red} Depends on the system size? Is it 2f+1 or what?} Since each acceptor will only vote for a single sequence, there are only enough correct processes to commit one of them. Note that the fact that proposals are sent as extensions of previous sequences is critical to the safety of the protocol. In particular, since the votes from acceptors can be reordered by the network before being delivered at the learners, if these values were single commands it would be impossible to guarantee that non-commutative commands would be learned in a total order. \par

\noindent \textbf{Arbitrating an order after a conflict.} When, in a fast ballot, non-commutative commands are  concurrently proposed, these commands may be incorporated into the sequences of various acceptors in different orders, and therefore the sequences sent by the acceptors in phase $2b$ messages will not be equivalent and will not be learned. In this case, the leader subsequently runs a classic ballot and gathers these unlearned sequences in phase $1b$. Then, the leader will assemble a single serialization for every previously proposed command, which it will then send to the acceptors. Therefore, if non-commutative commands are concurrently proposed in a fast ballot, they will be included in the subsequent classic ballot and the learners will learn them in a total order, thus preserving consistency. \par 
Note that the leader may assemble gathered sequences in an order that is non-commutative to some sequence that has previously gathered enough votes to be learned. Since the leader can only wait $N-f$ phase $1b$ messages from acceptors, there is no way guarantee which sequence may have been learned. However, this is not a problem because, by making learners process phase $2b$ messages in order, if some sequence gathered enough votes to be learned then its commands will be learned before the new non-commutative sequence is and the new-sequence's repeated commands will be discarded.\par

\subsection{Discussion}
\subsubsection{Generalized Paxos and weak consistency}
%The Byzantine Generalized Paxos protocol tackles two challenges in two different avenues of research, fault tolerance and relaxed consistency models. By specifying the generalized consensus problem,
The key distinguishing feature of the specification of Generalized
Paxos~\cite{Lamport2005} is allowing learners to learn concurrent
proposals in a different order, when the proposals commute. This idea
is closely related to the work on weaker consistency models like eventual or
causal consistency~\cite{Ahamad1995}, or consistency models that mix
strong and weak consistency levels like RedBlue~\cite{Li2012}, which attempt
to decrease the cost of executing operations by reducing coordination
requirements between replicas. 

The link between the two models becomes clearer with the introduction of 
universally commutative commands in the previous subsection.
In the case of weakly consistent replication (or multi-level replication),
weakly consistent requests can be executed as if they were universally
commutative, even if in practice that may not be the case. E.g., checking 
the balance of a bank account and making a deposit do not commute since
the output of the former depends on their relative order. However,
some systems prefer to run both as weakly consistent operations, even
though it may cause executions that are not explained by a sequential
execution, since the semantics are still acceptable given
that the final state that is reached is the same and no invariants 
of the application are violated~\cite{Li2012}.

\iffalse 
\subsubsection{Fastness in simplified Generalized Paxos} 
The relaxation of the generalized consensus problem can yield several interesting results, one of which is enabling learning proposals in two message steps while using traditional majority quorums. To understand how this is possible we must first understand why both Fast and Generalized Paxos require the total system size and the quorums to increase with the number of faults one wishes to tolerate while still allowing for fast executions. \par
The increased quorum requirements arise from the necessity of defining a rule for the leader to pick a value to be sent in its phase $2a$ messages~\cite{Lamport2006}. After executing phase $1$, the leader has gathered a quorum $Q$ of phase $1b$ messages from the acceptors relaying their votes regarding the latest ballot. In the common case, no value has been picked by the acceptors for the current ballot, but this is not necessarily the case since, in the case of a leader failure, new leaders are not guaranteed to be aware of the latest round. To further complicate the problem, since fast ballots allow multiple values to be concurrently proposed, the acceptors can relay different values voted for in the previous ballot. Intuitively, if for a ballot $k$ some value $v$ has already been sent by a previous leader to the acceptors such that a majority voted for it, no other value will be accepted. Lamport states that:\par

\begin{displayquote}
	\textbf{Observation 4.} (...) a value $v$ has been or might yet be chosen in round $k$ only if there exists a $k$-quorum $R$ such that $vr(a)=k$ and $vv(a)=v$ for every acceptor in $R \cap Q$.
\end{displayquote}

To determine the leader's behavior, it's useful to think what actions are available when the leader has gathered $Q$:
\begin{itemize}
	\item If no value satisfies Obs. 4 and no value is guaranteed to have been picked, then the leader can choose any value present in the phase $1b$ messages.
	\item If one value $v$ satisfies Obs. 4 then that value is the only value that has been or might yet be picked in round $k$ and the leader can only pick $v$ in phase $2a$.
	\item If there is more than one value that satisfies Obs. 4, then the leader has no way of choosing a value.
\end{itemize} 

Lamport solves this problem by making the third case impossible. He does this by noticing that this case requires Obs. 4 to be true for two distinct values $v$ and $w$, which implies that there are $k$-quorums $R_v$ and $R_w$ such that every acceptor in $R_v \cap Q$ has voted for $v$ and every acceptor in $R_w \cap Q$ has voted for $w$. This becomes impossible if we force $R_v \cap R_w \cap Q \neq \emptyset$. This rule is formalized as:

\begin{displayquote}
	\textbf{Quorum Requirement} For any round numbers $j$ and $i$:\par
	(a) Any $i$-quorum and any $j$-quorum have a non-empty intersection.\par
	(b) If $j$ is a fast round number, then any $i$-quorum and any two $j$-quorums have non-empty intersection. 	
\end{displayquote}

The system and quorums sizes can then be defined with respect to parameters $f$ and $e$, respectively, the maximum number of faults the system can tolerate while still being able to function correctly and the maximum number of faults the system can tolerate while still being able to support two step executions. The system size $N$ must take into account the following restrictions: $N > 2f$ and $N < 2e+f$. If we wish to always allow fast executions then $e=f$ and the minimum value of $N$ becomes $3f+1$. Similarly, the fast and classic quorums both become $N-e=N-f= 2f+1$. This is the cost imposed on the system in order to allow the safe learning of values in two message steps. \par
As previously mentioned, this cost stems from the necessity of picking a single value to be sent from the leader to the acceptors. However, notice that the leader in the analogous protocol for our simplified generalized consensus problem isn't constrained by the same requirement. This is due to the fact that, to ensure liveness, the leader picks a serialization composed of every value sent to the acceptor in the previous fast ballot. Since the leader doesn't have to pick a single value present in the acceptors' phase $1b$ messages, Fast and Generalized Paxos' quorum requirements are unnecessary and it is sufficient to ensure the standard quorum assumption that any two quorums have a non-empty intersection. Therefore, our simplified problem statement allows us to do away with the previous cost of learning values in two message steps.
\fi