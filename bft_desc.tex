
We now present the adapted Generalized Paxos protocol for a Byzantine adversary.\par
\textbf{View Change} The goal of the view change sub-protocol is to ensure that when $f+1$ processes suspect the leader to be faulty all correct processes commit to a new view and stop participating in lower-numbered views. To this end, processes can multicast suspicion messages if they believe that the leader is faulty. Suspicions contain the current view number, signed by the sending process in a verifiable way. This signature is the digest of sender's identification and current view number, encrypted by the suspecting process's private key. If a correct process receives $f+1$ suspicions, it stops participating in the previous view and multicasts a view-change message. View-change messages contain a ballot number, the previously committed ballot and value, and the $f+1$ suspicions, including the signature. If a process receives a view-change message without previously receiving $f+1$ suspicions, it can verify the suspicions, commits to the new view and multicasts a view-change message. The signature allows a process that receives this message to commit to the new view and multicast its own view-change messages without receiving $f+1$ suspicions itself. The process must only confirm that the signatures are valid and correspond to suspicions sent by distinct processes for the current view. This guarantees that if one correct process received the $f+1$ suspicions and broadcasted the view-change message, then all correct processes will receive that message, validate the proof of $f+1$ suspicions and switch to the new view. Processes start participating in the new view as soon as they broadcast their view-change messages, since the multicast of one correct view-change message is all it takes to ensure that all correct process will eventually switch to the new view. The only process that must wait for $2f+1$ view-change messages is the leader of the new view since, to send new sequences, it needs to know the values voted for in the last ballot for a quorum of acceptors. \par
\textbf{View Change Proof} We can prove that $f+1$ suspicions trigger a new view successfully since as soon as one process receives those suspicions it will broadcast a view-change message containing a proof that $f+1$ processes suspect the leader. When other processes receive either the $f+1$ suspicions or the view-change message, they will broadcast their own view-change messages and start participating in the new view. Faulty processes alone can't force a new view since $f+1$ suspicions are required for any correct process to commit to the new view.\par
\textbf{Agreement Protocol} The consensus protocol allows processes to agree on equivalent sequences of commands. Each consensus instance is called a ballot, which can be \textit{classic} or \textit{fast}. In classic ballots, a leader proposes a single sequence of commands which is learned by the learners. In fast ballots, multiple proposers can concurrently propose single commands to acceptors which send their votes to learners. Concurrency implies that acceptors may send votes in different orders but the protocol ensures that, as long as the resulting sequences are equivalent, the commands will be learned in two message delays. A classic ballot in Generalized Paxos contains a first phase where the leader obtains a promise that the acceptors will not participate in lower-numbered ballots and the sequence that the acceptor voted for. This first phase becomes unnecessary when a classic ballot is executed after the view change, since the leader already gathered the last committed sequences and no promise is required from the acceptors. The leader doesn't need to ask the acceptors not to participate in lower-numbered ballots because, for the remainder of the current view, the leader is the only process that can start a new ballot. \todo{Is there any problem if an acceptor receives an accept message out-of-order? I believe not} However, the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot, since the acceptors may have voted for new sequences. \par
\textbf{Classic Ballots} In a classic ballot, proposers send their proposed commands to the leader who sends a single sequence of commands to the acceptors. This sequence is built by appending the new proposals to the only sequence that may have been committed in the previous ballot, if any such sequence exists. The leader starts by sending phase 1a messages to acceptors, which respond with the last value for which they have voted for. If, among the reported values, there are multiple non-commutative sequences then at most one of them was learned. In order for the leader to pick the committed sequence, he must gather $x$ phase 1b messages for that value. We define $x$ as the number of votes for a certain sequence $v$ that the leader must see in order to be sure that no sequence other than $v$ may have been learned. The reasoning for the derivation of this quantity is the following: the leader must see a certain amount of votes $x$ for a sequence $v$ such that the remaining acceptors $N-x$ are not enough to form a fast quorum $\lceil\frac{3N}{4}\rceil$ for any sequence other than $v$. More formally: 
\begin{gather*} \\
N - x < Q_f \label{eq_1} \tag{1} \\ 
N - x < N - E \label{eq_2} \tag{2} \\
-x < -E \label{eq_3} \tag{3} \\
x > E \label{eq_4} \tag{4} \\
\end{gather*}

Lamport defines $E$ as the number of acceptors that can fail while still allowing a fast round to succeed \cite{L06}. With the minimum $E$ of $\lfloor\frac{N}{4}\rfloor$ and implicitly a fast quorum size of $\frac{3N}{4}$, $x$ would become:
\begin{gather*} \\
N - x < Q_f \label{eq_1} \tag{1} \\ 
N - x < \lceil\frac{3N}{4}\rceil \label{eq_2} \tag{2} \\
3f+1 - x < \frac{3*(3f+1)}{4} \label{eq_3} \tag{3} \\
12f+4 -4x < 9f+3 \label{eq_4} \tag{4} \\ 
3f+1 < 4x \label{eq_5} \tag{5} \\ 
x > \frac{3f+1}{4} \label{eq_6} \tag{6} \\ 
\end{gather*}

This is coherent with the more generic expression of $x > E$ since, with $E = \lfloor\frac{N}{4}\rfloor$ and $N = 3f+1$, we arrive at the same result: 
\begin{gather*} \\
x > E  \\
x > \lfloor\frac{N}{4}\rfloor \\
x >\frac{3f+1}{4}\\
\end{gather*}

\todo{What if some acceptors only receive some of the commands in a fast ballot and then reject the leader's sequence because it's not an extension?}

However, since the system is operating under the Byzantine assumption, we must gather $x+f$ reports in order to be sure that $x$ actually sent those votes. So the leader must gather more than $E+f$ votes for a given sequence. Also note that even if the leader gathered $E+f$ votes for a sequence $v$, this doesn't mean that $v$ was learned. However, since it means that no other sequence may have been learned, we can safely incorporate it in the new sequence without violating any property. \par
After augmenting the chosen sequence with new commands, the leader computes the digest of the new sequence and signs the digest with its private key. This signed digest is sent with the proposal and serves as a proof that the sequence was composed by the leader. In order to verify the sequence against the proposal, any process can compute digest of the sequence, decipher the encrypted digest with the leader's public key and compare the two. If both digests match and the leader's private key wasn't shared with a other process, it was the leader that composed the sequence. \todo{This still leaves us with the scenario where the leader shares his private key (because he is byzantine)} This ensures us that when a leader gathers the state from the acceptors, even faulty ones can only report values sent by the leader of the view in which the sequence was sent. This means that Byzantine acceptors can't covertly insert commands in the command history. At most, they can send an out-of-date value along with its proof. However, since the leader must gather values and ballot numbers from at least $2f+1$ processes, either in the view change or in phase 1, some correct process that participated in the last ballot is guaranteed to respond correctly. Therefore, the leader can calculate which sequence to extend by finding more than $x+f$ votes for an unforged sequence. The leader sends the sequence to the acceptors which, in turn, verify the sequence against the encrypted digest and send both to the learners. The learners verify that the new sequence is an extension of the previously learned value, to avoid violating the stability property. After receiving $2f+1$ messages, the learners learn the value present in at least $f+1$ messages. \par
\textbf{Fast Ballots} To initiate a fast ballot, the leader broadcasts an \textit{any} value to inform proposers that they may propose directly to the acceptors. Proposals are sent in the form of a single command to be appended to the command history. These proposals are sent to the acceptors that send their votes to the learners. To learn a proposal, a learner must receive $N-E$ votes. However, since non-commutative commands may be concurrently proposed, a verification round is needed to ensure that conflicting commands aren't learned by different learners in different orders. To this end, after receiving $N-E$ messages from acceptors, a learner broadcasts a verification message to the other learners. A learner only responds to a verification request after receiving it from more than $f$ learners since less than that would allow Byzantine learners to prevent conflicting commands from being committed. When a learner receives more than $f$ requests for verification of a certain command and it commutes with every other value learned in the same fast ballot, the learner broadcasts an acknowledgment that the value is safe to be learned. Upon receiving more than $2f$ acknowledgments to a verification request, a learner can safely learn the sequence. If a proposed command is non-commutative with an already learned command and some learner tries to learn it, at least one correct learner that has acknowledged the first non-commutative value will notice the conflict and ignore the request. Therefore, only one of two non-commutative proposals can be learned in each ballot. \par
\textbf{Verification Round Proof} The verification round ensures the consistency property by preventing learners from learning conflicting commands in different orders. For two learners to learn conflicting commands, they would both have to receive an acknowledgment from a correct learner. However, since a correct learner can only learn after receiving $2f+1$ acknowledgments to his verification request and no correct learner can would send an acknowledgment to two non-commutative commands, one of the values can receive at most $2f$ acknowledgments ($f$ byzantine learners and $f$ that may not have seen the previous command) which isn't enough to learn the command.