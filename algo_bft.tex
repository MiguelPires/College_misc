%\subsection{Pseudocode}
%The following pseudocode implements the Byzatine Generalized Paxos protocol.% We assume that $N = 3f+1$ and therefore, $E = f$.

\begin{algorithm} 
	\caption{Byzantine Generalized Paxos - Proposer p}
	\label{BFT-Prop}
	\textbf{Local variables:} $ballot\_type = \bot$
	\begin{algorithmic}[1]
			
		\State \textbf{upon} \textit{receive(BALLOT, type)} \textbf{do} 
		\State \hspace{\algorithmicindent} $ballot\_type = type$;
		\State
		
		\State \textbf{upon} \textit{command\_request(c)} \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $ballot\_type = fast\_ballot$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$P2A\_FAST, c$} to acceptors;
		\State \hspace{\algorithmicindent} \textbf{else} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{\textit{PROPOSE, c}} to leader;		
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Byzantine Generalized Paxos - Learner l}
	\label{BFT-Learn}
	\textbf{Local variables: } $learned = \bot,\ messages = \bot$ 
	\begin{algorithmic}[1]
		\State \textbf{upon} \textit{receive($P2B, ballot, values, certificates$)} from acceptor $a_i$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{for} $bal$ \textbf{in} $0..ballot$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $a$ \textbf{in} $acceptors$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $val$ \textbf{in} $values[bal]$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = certificates[bal][a][val]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $\langle ballot, value \rangle = proof_{pub_a}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $messages[a][bal] =messages[a][bal] \bullet val$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}
		
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}
		\State \hspace{\algorithmicindent} \textbf{end for}
		
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $\#(messages) \geq N-F$ \textbf{then}
		\State
		\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $a$ \textbf{in} $acceptors$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $bal$ \textbf{in} $0..ballot$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $seq =  messages[a][bal]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}
		$learned = \Call{remove\_duplicates}{learned \bullet seq}$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}	
	\end{algorithmic}
\end{algorithm}

\begin{algorithm} 
	\caption{Byzantine Generalized Paxos - Process p}
	\label{BFT-Proc}
	\textbf{Local variables:} $suspicions = \bot,\ new\_view = \bot,\ leader = \bot,\ view = 0$
	\begin{algorithmic}[1]
		
		\State \textbf{upon} \textit{suspect\_leader} \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $suspicions[p] \neq true$ \textbf{then}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $suspicions[p] = true$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = \langle suspicion, view \rangle_{priv_p}$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$suspicion, view,proof$};	
		\State
		
		\State \textbf{upon} \textit{receive($SUSPICION, view_i, proof$)} from process $p_i$ \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $view_i \neq view$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{return};
		\State
		\State \hspace{\algorithmicindent} $suspicions[p_i] = proof$;
		\State \hspace{\algorithmicindent} \textbf{if} $\#(suspicions) > f$ and $new\_view[p] = \bot$ \textbf{then}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $new\_view[p] = \langle last\_bal,\ last\_val \rangle$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent}  \Call{send}{$VIEW\_CHANGE, view+1, last\_bal, last\_val, suspicions$};
		\State
		
		\State\textbf{upon} \textit{receive($VIEW\_CHANGE, view_i, last\_bal_i, last\_val_i, suspicions$)} 
		\item[] from process $p_i$ \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $view_i \leq view$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\textbf{return};
		\State
		\State \hspace{\algorithmicindent} \textbf{for} $p$ \textbf{in} $processes$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = suspicions[p]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof \neq \langle suspicion, view_i \rangle_{pub_{p_i}}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{return};
		
		\State
		\State\hspace{\algorithmicindent} $new\_view[view_i][p_i] = \langle last\_bal_i,\ last\_val_i \rangle$;
		\State\hspace{\algorithmicindent} \textbf{if} $new\_view[view_i][p] = \bot$ \textbf{then}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $new\_view[view_i][p] = \langle last\_bal,\ last\_val \rangle$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent}  \Call{send}{$VIEW\_CHANGE, view_i, last\_bal, last\_val, suspicions_{\sigma_i}$};
		\State
		\State\hspace{\algorithmicindent} \textbf{if} $\#(new\_view[view_i]) > N-f$ \textbf{then}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $view = view_i$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $leader = n\ mod\ view$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $suspicions = \bot$;
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} $new\_view = \bot$;

		\iffalse\State
		\Function{is\_prefix}{$extension, prefix$}
		\If {$\lVert prefix \rVert > \lVert extension \rVert$}
		\State \textbf{return} \textit{false};
		\EndIf
		
		\State
		\item[] outer:	
		\State \textbf{for} $c_{old}$ in $prefix$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{for} $c_{new}$ in $extension$ \textbf{do}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $c_{old} = c_{new}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{continue} \textit{outer};
		
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{else if} !\Call{are\_commutative}{$c_{old}, c_{new}$} \textbf{then}
		\State\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{return} \textit{false};
		\State \hspace{\algorithmicindent}\textbf{end for}
		\State \hspace{\algorithmicindent}\textbf{return} \textit{false};
		\State \textbf{end for}
		\State
		\State \textbf{return} \textit{true};
		\EndFunction
		\fi
	\end{algorithmic}
\end{algorithm}

\begin{algorithm} 
	\caption{Byzantine Generalized Paxos - Leader l}
	\label{BFT-Lead}
	\textbf{Local variables:} $ballot_l = 0,\ maxTried_l = \bot,\ proposal = \bot,\ accepted = \bot$
	\begin{algorithmic}[1]
		\State \textbf{upon} \textit{trigger\_next\_ballot(type)} \textbf{do}
		\State \hspace{\algorithmicindent} $ballot_l \mathrel{+{=}} 1$;
		\State \hspace{\algorithmicindent} \Call{send}{$FAST,ballot_l, type}$ to acceptors;
		\State \hspace{\algorithmicindent} \Call{send}{$BALLOT,type}$ to proposers;

		\State
		\State \textbf{upon} \textit{receive(PROPOSE, prop)} from proposer $p_i$ \textbf{do} 
		\State \hspace{\algorithmicindent} \Call{phase\_1a}{$prop$};
		\State
		\State \textbf{upon} \textit{receive($P1B, m, bal_a,acc\_values, certificates$)} from acceptor $a$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $m = ballot_l$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}
		$sequence = \bot$;
		
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} 
		\textbf{for} $value$ \textbf{in} $acc\_values$ \textbf{do}
		\State 
		\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof\_counter = 0$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $a$ \textbf{in} $acceptors$ \textbf{do}
		\State 
		\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} 
		$proof = certificates[a][value]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof_{pub_a} = \langle bal_a, value \rangle$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof\_counter \mathrel{+{=}} 1$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}
		\State
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof\_counter \geq N-f$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $sequence = sequence \bullet value$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{end for}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}  $accepted[ballot_l][a] = sequence$;
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $\#(accepted[ballot_l]) \geq N-f$ \textbf{then} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{phase\_2a}{$ $};

		\State
		%\item[] % unnumbered empty line
		\Function{phase\_1a}{$prop$}
		\State $proposal = prop$;
		\State \Call{send}{$P1A, ballot_l$} to acceptors;
		\EndFunction
		
		\State
		\Function{phase\_2a}{$ $}
		\State $maxTried_l = \Call{proved\_safe}{ballot_l}$;
		\State $maxTried_l = maxTried_l \bullet proposal$;
		\State \Call{send}{$P2A,ballot_l, maxTried_l$} to acceptors;
		\EndFunction
		
		\State
		\Function{proved\_safe}{$ballot$}
		\State $safe\_seq = \bot$;
		\State \textbf{for} $seq$ \textbf{in} $accepted[ballot]$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{for} $c$ \textbf{in} $seq$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $!\Call{Contains}{safe\_seq,c}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $safe\_seq =  safe\_seq \bullet c$;
		\State \hspace{\algorithmicindent} \textbf{end for}
		\State \textbf{end for}
		\State \textbf{return} $safe\_seq$;
		\EndFunction
		
		\iffalse \State
		\Function{proved\_safe}{Q, m}
		\State $k = max(i\ |\ (i < m) \wedge (\exists a \in Q :\ val_a[i]\ \neq null))$;
		\State $RS = \{R \in k$-$quorum\ |\ \forall a \in R \cap Q : val_a[k] \neq null\}$;
		\State $\gamma(R) = \sqcap \{v_a[k]\ |\ a \in Q \cap R \}$;
		\State $\Gamma = \{\gamma(R)\ |\ R \in RS \}$;
		\State
		\If{$RS = \varnothing$}
		\State \textbf{return} $\{val_a[k]\ |\ (a \in Q) \wedge (val_a[k] \neq null)\}$;
		\Else
		\State \textbf{return} $\sqcup \Gamma$;
		\EndIf
		\EndFunction
		\fi
		
	\end{algorithmic}
\end{algorithm}

\begin{algorithm} 
	\caption{Byzantine Generalized Paxos - Acceptor a}
	\label{BFT-Acc}
	\textbf{Local variables:} $bal_a = 0,\ val_a = \bot,\ certificates = \bot,\ acc\_values = \emptyset,\ proof\_counter = \bot,\ fast\_bal = \bot$ 
	\begin{algorithmic}[1]
		\State
		\State \textbf{upon} \textit{receive(P1A, ballot)} from leader \textit{l} \textbf{do}
		\State \hspace{\algorithmicindent} \Call{phase\_1b}{$ballot, l$};
		
		\State
		\State \textbf{upon} \textit{receive(FAST,ballot)}
		\State \hspace{\algorithmicindent} $fast\_bal[ballot] = true$;
		
		\State
		\State \textbf{upon} \textit{receive(P2A\_CLASSIC, ballot, value)} from leader \textit{l} \textbf{do}
		\State \hspace{\algorithmicindent} \Call{phase\_2b\_classic}{$ballot, value$}; 

		\State		
		\State \textbf{upon} \textit{receive(P2A\_FAST, value)} from proposer \textit{p} \textbf{do}
		\State \hspace{\algorithmicindent} \Call{phase\_2b\_fast}{$value$};
		
		\State 
		\State \textbf{upon} \textit{receive(VERIFY, ballot, value, proof)} from acceptor $a_i$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $\langle ballot, value \rangle = proof_{pub_{a_i}}$ and $!\Call{conflict}{value,val_a[ballot]}$  \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $certificates[ballot][a_i][value] = proof$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof\_counter[ballot][value][a] = true$;
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $\#(proof\_counter[ballot][value]) \geq N-f$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$P2B, ballot, val_a, certificates$} to learners;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $acc\_values = acc\_values \cup  value$;
			
		\State
		\Function{phase\_1b}{$ballot, l$}
		\If {$bal_a < ballot$}
		\State \Call{send}{$P1B, ballot, bal_a, acc\_values, certificates[bal_a]$} to leader l;
		\State $bal_a = ballot$;	
		\State $val_a[bal_a] = \bot$;	
		\State $acc\_values = \emptyset$;		
		\EndIf
		\EndFunction
	
		\State
		\Function{phase\_2b\_classic}{$ballot, value$}
		\If {$ballot \geq bal_a$ and $val_a = \bot$}
		\State $bal_a = ballot$;
		\State $val_a[ballot] = value$;
		\State $proof = \langle ballot, value \rangle_{priv_a}$;
		\State $certificates[ballot][a][value] = proof$;
		\State \Call{send}{$VERIFY, ballot, value, proof$} to acceptors;
		\EndIf
		\EndFunction
		
		\State
		\Function{phase\_2b\_fast}{$value$}
		\If {$fast\_bal[]bal_a]$ and $!\Call{conflict}{value, val_a}$}
		\State $val_a[bal_a] =  val_a[bal_a] \bullet value$;
		\State $proof = \langle bal_a, value \rangle_{priv_a}$;
		\State $certificates[ballot][a][value] = proof$;

		\State \Call{send}{$VERIFY, ballot, value, proof$} to acceptors;
	%	\State \Call{send}{$p2b, bal_a, val_a$} to learners;
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}
