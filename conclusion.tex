\chapter{Conclusion} \label{conclusion}
This dissertation focuses on the problem of achieving consensus in a distributed system and its solutions. In particular, this work builds upon one of the protocols of the widely known Paxos family of consensus-solving protocols, Generalized Paxos~\cite{Lamport2005}. This protocol makes use of a generic consensus problem that uses special structures, called \textit{c-structs}, to allow for the definition of any consensus problem. By solving this generalized consensus problem, Generalized Paxos is able to present a solution that covers a broad spectrum of problems. One of which was the command history problem that makes the observation that commands don't necessarily conflict with each other and may result in the same state being produced regardless of the order in which they are executed. This problem allows coordination requirements to be reduced since not every commands is required to be committed in a total order. However, the generality of this consensus problem comes at the cost of a very complex specification of both generalized consensus and Generalized Paxos. With this in mind, of the initial goals of this work was to produce a specification that still took advantage of the command history problem but didn't carry with it all the generality that made the original problem and protocol so complex. \par
The Paxos protocol family also includes variants that reduce the number of message steps required to learn a value. The aforementioned Generalized Paxos protocol is one of these protocols that enable the system to learn commands in just two message steps instead of the usual four. This fastness relative to the protocol's broadcast rounds comes at the cost of increasing the system's quorum sizes and total number of processes in function of the number of faults that we wish to tolerate while still allowing two-step executions. This work also intended to retain this property whenever doing so didn't imply an unreasonable cost in another aspect of the protocol. \par
Another facet of the distributed systems literature focuses on the Byzantine fault model, in which protocols are designed to withstand not only crash faults but also arbitrary and possibly malicious behavior by some of the system's participants. Several works make their contributions in this field by extending consensus solving algorithms to the Byzantine model. However, few works have aligned this goal with the previously stated ones, namely allowing fast executions and taking advantage of the commutativity assumption to reduce coordination requirements. This is a sparse are in the distributed protocols literature to which we wanted to contribute.\par
Finally, newer non-crash fault models make the observation that the Byzantine model is very pessimistic in that it allows for up to $f$ processes to display malicious behavior in a coordinated way. In order to reduce the stringent system requirements imposed by the strong faulty behavior permitted to the processes, models like VFT and XFT have introduced specifications that allow the network administrator to parameterize the allowed behavior. These models are especially suited for datacenter environments where not only is the network highly secured and monitored, making coordinated malicious behavior unlikely, but the high amount of required equipment makes protocols with less requirements more attractive. Protocols can take advantage of the realistic assumptions provided by these models to become more viable options in scenarios like the one mentioned previously. Therefore, we also wanted to build a version of the protocol that took advantage of these newer models to be better suited for datacenter environments and perhaps scenarios in which systems are geo-replicated. \par

\section{Achievements}


\section{Future work}
