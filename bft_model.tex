\section{Model} \label{bft_model}

In this section, we define our simplified consensus problem for the Byzantine model and describe how the possibility of Byzantine faults has an effect on both the network assumptions and the fault model. We start by describing the fault and network assumptions in which the protocol will function and then we move on the consensus specification itself.

\subsection{Network model}
For the Byzantine tolerant protocol, we consider an \emph{asynchronous} system in which a set of $n \in \mathbb{N}$ processes communicate by \emph{sending} and \emph{receiving} messages. Furthermore, for clarity of exposition, we assume authenticated perfect links~\cite{cgr:book}, where a message that is sent by a non-faulty sender is eventually received exactly once and the receiver is guaranteed that the message originated from its stated sender (such links can be implemented trivially using retransmission, elimination of duplicates, and point-to-point message authentication codes~\cite{cgr:book}). As is the case in the \acrshort{cft} protocol, each process executes an algorithm depending on its role, which can be of proposer, acceptor or learner (a process can have multiple roles simultaneously). Our protocol requires a minimum number $N$ of acceptor processes and we assume that they have identifiers in the set $\{0,...,N-1\}$. In contrast, the number of proposer and learner processes can be set arbitrarily.

\subsection{Fault model}
Each process executes an algorithm assigned to it according to its role, but may fail in two different ways. First, it may stop executing it by \emph{crashing}. Second, it may stop following the algorithm assigned to it, in which case it is considered \emph{Byzantine}. We say that a non-Byzantine process is \emph{correct}. Our protocol functions under the \emph{authenticated} Byzantine model where every process can produce cryptographic digital signatures~\cite{quorum}. The number of acceptor processes $N$ is a function of the maximum number of tolerated Byzantine faults $f$, namely $N \ge 3f+1$, and quorums are any set of $N-f$ processes. 

\subsection{Problem statement}
As in the \acrshort{cft} version of our simplified specification of Generalized Paxos, each learner $l$ maintains a monotonically increasing sequence of commands $learned_l$. Similarly, our definition of equivalence remains the same as it was defined in Section \ref{cft_problem}, where we define two learned sequences of commands to be equivalent ($\thicksim$) if one can be transformed into the other by permuting the elements in a way such that the order of non-commutative pairs is preserved. A sequence $x$ is defined to be an \textit{eq-prefix} of another sequence $y$ ($x \sqsubseteq y$), if the subsequence of $y$ that contains all the elements in $x$ is equivalent ($\thicksim$) to $x$. 
We present the requirements for this consensus problem, stated in terms of learned sequences of commands for a correct learner $l$, $learned_l$. 
Our specification of consensus for the Byzantine fault model discards consists in the Byzantine version of the problem of agreeing on equivalent sequences of commands, instead of being Byzantine version of the original generalized consensus problem that uses \textit{c-structs}. The requirements of the our consensus problem for the Byzantine model are:\par
%
\begin{enumerate}
	\item \textbf{Nontriviality.} If all proposers are correct, $learned_l$ can only contain proposed commands.
	\item \textbf{Stability.} If $learned_l = s$ then, at all later times, $s \sqsubseteq learned_l$, for any sequence $s$ and correct learner $l$.
	\item \textbf{Consistency.} At any time and for any two correct learners $l_i$ and $l_j$, $learned_{l_i}$ and $learned_{l_j}$ can subsequently be extended to equivalent sequences.
	\item \textbf{Liveness.} For any proposal $s$ from a correct proposer, and correct learner $l$, eventually $learned_l$ contains $s$.
\end{enumerate}
