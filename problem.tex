\chapter{Consensus Problem} \label{problem}

One of our most important contributions is the revised consensus problem. In Lamport's original specification, the consensus problem is generalized from agreeing on a single value to agreeing on an increasing set of values~\cite{Lamport2005}. The consensus problem is defined in terms of \textit{c-structs} and includes four properties, where $learned[l]$ is the sequence of commands learned by a learner $l$, $propCmd$ is the set of all proposed commands and $Str(propCmd)$ is the set of all \textit{c-structs} that can be constructed from the elements in $propCmd$:
\begin{itemize}
	\item \textbf{Non-Triviality} $learned[l] \in Str(propCmd)$ always holds, for every learner $l$.
	\item \textbf{Stability} It is always the case that $learned[l] = v$ implies $v \sqsubseteq learned[l]$ at all later times, for any learner $l$ and \textit{c-struct} $v$.
	\item \textbf{Consistency} $learned[l_1]$ and $learned[l_2]$ are always compatible, for all learners $l_1$ and $l_2$.
	\item \textbf{Liveness} If $c \in propCmd$ then eventually $learned[l]$ contains $c$.
\end{itemize}

\par
Two of the reasons why the generalized consensus problem and its solution, the Generalized Paxos protocol, are so hard to understand, is due to the amount of mathematical operations defined and how they're used to compose a consensus-solving algorithm. In the following sections, we will step through these mathematical formalisms and provide the intuition as to how they're used in the Generalized Paxos protocol. We will also provide some insights on other non-trivial components of Generalized Paxos that require careful examination of the original description in order to be understood. Since these components are profoundly affected by our simplification of generalized consensus, it makes sense for us to describe their original form. Later chapters will introduce the simplified consensus problem appropriate for each fault model and also describe how some important issues are solved in light of the new problem. This chapter allows us to draw a clear parallelism between those descriptions and the original generalized consensus problem.

\section{Operations on \textit{C-structs}} \label{Operations}
The consistency property stated above defines what a consensus-solving protocol must guarantee to be considered \textit{safe}. In generalized consensus, consistency relies on a notion of \textit{compatibility} between \textit{c-structs}. As Lamport states, two \textit{c-structs}, $v$ and $w$ are compatible if and only if they have a common upper bound, that is, if there exists a \textit{c-struct} $z$ to which they are both prefixes, $v \sqsubseteq z \land w \sqsubseteq z$. Intuitively, this means that if two \textit{c-structs} can be extended to the same \textit{c-struct}, then each can be learned by a different learner without violating consistency. However, if two \textit{c-structs} contain conflicting commands in different relative orders, then there is no \textit{c-struct} that extends both and the \textit{c-structs} are cannot be safely learned. {\color{red}This notion is crucial to the understanding of generalized consensus and, even though our simplified problem forgoes \textit{c-structs} in favor of sequences of commands, our safety condition also relies on the idea of two sequences being able to be extended to equivalent sequences.\par
As previously mentioned, generalized consensus' consistency specification relies on the notion of compatibility which, in turn, relies on the notion of a \textit{common upper bound}. An upper bound of a set $T$ is a \textit{c-struct} $v$ such that $w \sqsubseteq v$ for any $w$ in $T$. Intuitively, an upper bound is an extension of every \textit{c-struct} in a set. A lower bound of a set $T$ is defined analogously as a \textit{c-struct} $v$ such that $v \sqsubseteq w$ for any $w$ in $T$. Upper and lower bounds are most commonly used in Generalized Paxos as components in two operations, least upper bounds $\sqcup$ and greater lower bounds $\sqcap$.} A least upper bound $\sqcup$ of a set of \textit{c-structs} $T$ is an upper bound $v$ of $T$ such that $v \sqsubseteq w$ for any upper bound $w$ of $T$. One could define this operation $\sqcup T$ as the upper bound of $T$ that is a lower bound of every upper bound in $T$. Note that if $v = w$ then $v\sqsubseteq w$ and $w\sqsubseteq v$. Analogously, a greater lower bound $\sqcap$ of a set of \textit{c-structs} $T$ is a lower bound $v$ of $T$ such that $w \sqsubseteq v$ for any lower bound $w$ of $T$. \par
{\color{red} The operations we just defined are used in critical components of the Generalized Paxos protocol, namely in the leader's value picking procedure. However, the usage of these operations combined with the already complex functioning of some of Generalized Paxos' components makes it difficult for the reader to understand the semantics of what is being computed. In order to ease the later examination of components that rely on these operations, it's helpful to illustrate their execution with an example. Let $T$ be the set of \textit{c-structs} $\{A ; A \bullet B ; A \bullet B \bullet C\}$ and let the set of all \textit{c-structs} contain any combination of the commands $A$, $B$, $C$, $D$ and $E$, as long as they appear in alphabetical order (recall that Generalized Paxos allows for the definition of any consensus problem specified in terms of \textit{c-structs}).} If an upper bound of $T$ is a \textit{c-struct} $v$ such that $w \sqsubseteq v$ for any $w$ in $T$, then there are three possible upper bounds, namely $A \bullet B \bullet C$, $A \bullet B \bullet C \bullet D$ and $A \bullet B \bullet C \bullet D \bullet E$. Of these three upper bounds, we can compute $\sqcup T$ by noting that only the upper bound $A \bullet B \bullet C$ is a lower bound of all three upper bounds. {\color{red}As previously mentioned, the consistency property requires learned \textit{c-structs} to be compatible (i.e., to have a common upper bound). If the previously defined set $T$ was the set of learned sequences in a Generalized Paxos execution, then the system would be functioning correctly because any two \textit{c-structs} in $T$ are compatible (i.e., can be extended to some possible \textit{c-struct}). Any set of compatible \textit{c-structs} is guaranteed to have a least upper bound.}\par 
\begin{algorithm}
	\caption{Original Generalized Paxos - Excerpt from the leader's code}
	\label{leader_excerpt}
	\textbf{Local variables:} $ballot_l = 0,\ maxTried_l = \bot$
	\begin{algorithmic}[1]
		\Function{Phase\_2a}{$bal, Q$}
		\State $maxTried_l$ = \textbf{run} \Call{Proved\_Safe}{$Q, bal$};
		\State $maxTried_l = maxTried_l \bullet new\_proposals$;
		\State \textbf{run} \Call{send}{$p2a,ballot_l, maxTried_l$} to Acceptors;
		\EndFunction
		
		\State
		\Function{Proved\_Safe}{Q, m}
		\State $k = max(i\ |\ (i < m) \wedge (\exists a \in Q :\ val_a[i]\ \neq null))$;
		\State $RS = \{R \in k$-$quorum\ |\ \forall a \in R \cap Q : val_a[k] \neq null\}$;
		\State $\gamma(R) = \sqcap \{v_a[k]\ |\ a \in Q \cap R \}$;
		\State $\Gamma = \{\gamma(R)\ |\ R \in RS \}$;
		\State
		\If{$RS = \varnothing$}
		\State \textbf{return} $\{val_a[k]\ |\ (a \in Q) \wedge (val_a[k] \neq null)\}$;
		\Else
		\State \textbf{return} \textbf{run} $\sqcup \Gamma$;
		\EndIf
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}
Let's redefine the set $T$ to contain the following \textit{c-structs} $\{A ; A \bullet C ; A \bullet B \bullet C\}$. This may seem like an innocuous modification but it's enough to make the computation of $\sqcup T$ impossible. Taking into account the \textit{c-structs} in $T$, we can see that $T$ doesn't have an upper bound because there is no \textit{c-struct} to which every \textit{c-struct} in $T$ is a prefix. No upper bound of $A \bullet B \bullet C$ will also be an upper bound of $A \bullet C$. In other words, $A \bullet B \bullet C$ and $A \bullet C$ are not compatible. {\color{red} If $T$ was the set of \textit{c-structs} learned in a Generalized Paxos execution, the system wouldn't be functioning correctly because it's impossible to compute $\sqcup T$. Intuitively, we can see that this is because the \textit{c-structs} $A \bullet B \bullet C$ and $A \bullet C$ conflict with each other and, therefore, could never be learned by different learners.} \par 


\section{\textit{C-structs} in Generalized Paxos}
{\color{red}In section~\ref{Operations}, we mentioned how learned commands must be compatible in order for safety to be upheld. However, in order for this compatibility invariant to be preserved, the leader and the acceptors must act in a way that only causes compatible \textit{c-structs} to be learned. For this reason, the leader can't pick any value as his proposal before sending it to the acceptors. The previously defined operations are mostly employed in the procedure executed by the leader when choosing a value to which he can append the proposer's commands to. In \textit{phase 2a}, before sending new proposed commands to the acceptors, the leader must first pick a value to which its proposals will be appended.} To ensure that the consistency requirements are met, acceptors must only vote for \textit{safe} values. In this context, a \textit{c-struct} is safe if it's the extension of a choosable value at a lower ballot. In other words, if it was possible for a \textit{c-struct} $w$ to be chosen by a majority in a previous ballot and $w \sqsubseteq v$, then $v$ is safe. Therefore, to guarantee correctness, the leader must append new proposals to a safe \textit{c-struct}. The procedure that Generalized Paxos' leader follows in order to pick a safe \textit{c-struct} is depicted in Algorithm~\ref{leader_excerpt} in its original notation.\par

\begin{algorithm}
	\caption{Informal explanation of the Proved\_Safe procedure}
	\label{translation}
	\begin{algorithmic}[1]
		\Function{Proved\_Safe}{Q, m}
		\State $Q$ is the quorum gathered to vote for the current ballot $m$
		\State $k$ is the largest ballot number (but smaller than $m$) in which some acceptor in $Q$ voted for 
		\State $RS$ is the set of k-quorums (quorums possibly gathered at k) in which every acceptor also in $Q$ voted at $k$
		\State $\gamma(R)$ is the set of greater lower bounds of the votes sent by acceptors in both $R$ and $Q$
		\State $\Gamma$ is the set of greater lower bounds of the votes sent by acceptors in both $Q$ and a set where every acceptor also $Q$ voted at $k$
		\If{$RS$ is empty (there is no k-quorum $R$ for which every acceptor in $R$ and $Q$ have voted)}
		\State \textbf{return} Any value reported in phase $1b$ messages
		\Else
		\State \textbf{return} The least upper bound of $\Gamma$ (greater lower bounds of votes)
		\EndIf
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}

{\color{red}Algorithm \ref{translation} provides a translation of each line in the $Proved\_Safe$ procedure to an informal description. This is included to illustrate two things. First, how the complex notation of this procedure makes it difficult to understand or even translate into a practical implementation. Second, how, even in an informal format, the composition of the previously defined operations results in a procedure that is semantically difficult to follow. We believe this supports our argument that despite generalized consensus' great practical utility, its current state hampers its adaptation into a real implementation. Therefore, it's relevant and timely for the generalized consensus problem and its solution to be simplified as well as extended, wherever possible.\par
The following sections will discuss some of Generalized Paxos' components that are of particular importance to the protocol's correct functioning and whose original description can be difficult to parse.}

\section{Leader Value Picking Rule} \label{value_picking}

One of Generalized Paxos' most crucial components is the rule employed by the leader in order to choose its \textit{phase 2a} proposal in a given classic ballot. This rule is carefully constructed in order to not only allow the protocol to deal with conflicts between non-commutative proposals but also prevent a far more subtle situation in which consistency could be jeopardized. Consider a system of $N=3f+1$ acceptors where, in some fast ballot, two non-commutative commands, $A$ and $B$, are proposed. Consider also that a majority of acceptors votes for a sequence where $A$ precedes $B$ and the remaining $f$ acceptors vote for a non-commutative sequence. In this situation, the first sequence is chosen and learned at one learner but consider that the majority of votes is delayed before reaching a second learner. In the subsequent classic ballot, the leader would request \textit{phase 1b} messages from acceptors which would contain their votes on the previous fast ballot. Some of the values reported in the quorum of \textit{phase 1b} messages will contain $A$ preceding $B$ and others will contain non-commutative sequences. If the non-commutative sequence is chosen and sent to the acceptors in a \textit{phase 2a}, the learner in which the previous vote was delayed could receive a majority of votes for the leader's proposal and learn a sequence that conflicts with another learner's learned sequence. Therefore, the rule that governs the sequence picked by the leader must take into account the possibility that learners may have different views of the learned commands. Since it is unsafe for the leader to assume that the learners share the same view of learned commands at the beginning of a ballot, the leader must consider safety even when sequences are proposed in different ballots. \par
Generalized Paxos deals with this problem by having the leader of some ballot $m$ propose a sequence $w \bullet \sigma$, where $w$ belongs to the set of values returned by $Proved\_Safe(Q,m)$ and $\sigma$ is one possible serialization of the proposals sent by the proposers to the leader. In the original protocol, if a majority was reached in the previous fast ballot, the value $w$ is the value chosen by the acceptors present in the intersection between the quorum $Q$ of gathered \textit{phase 1b} messages and the quorum $R$ of \textit{phase 2b} messages sent to the learners in the previous ballot. Since the value sent by the leader in \textit{phase 2a} contains commands that were possibly learned in the previous ballot, a learner will also have to take that into account when it's learning. It can learn the leader's proposal safely by merging it with its $learned$ sequence in a way such that already learned commands are not duplicated in the $learned$ sequence. \par
{\color{red}Despite its importance to the correctness of Generalized Paxos, as we established in the previous section, the leader's value picking rule suffers in terms of understandability. Our simplified specification of consensus as agreement on commands histories allows us to describe this rule in clearer terms that could easily be transformed into a practical implementation. The protocols proposed throughout this work will feature different rules according both to the underlying fault model and to our simplified specification of consensus. }

\section{Quorum Sizes in Generalized Paxos} 
One of the main drawbacks of both Fast and Generalized Paxos is that they require both the total system size and the quorum size to increase with the number of faults one wishes to tolerate while still allowing for fast executions~\cite{Lamport2006,Lamport2005}. This is widely considered a direct consequence of allowing for learning proposals in two message steps. However, a reader unfamiliar with the Fast Paxos protocol may think that simple majority quorums suffice since a majority is enough for any two quorums to intersect which would prevent non-commutative values from being learned at different relative orders. In order to clarify this aspect of fast learning, we go through the original description step by step and gradually derive Fast Paxos' restrictions on quorum and system size. Although this section refers mostly to contributions stated in Fast Paxos, these insights are applicable to Generalized Paxos as well.\par
The increased quorum requirements arise from the necessity of defining a rule for the leader to pick a value to be sent in its \textit{phase 2a} messages~\cite{Lamport2006}. After executing \textit{phase 1}, the leader has gathered a quorum $Q$ of \textit{phase 1b} messages from the acceptors relaying their votes regarding the latest ballot. In the common case, no value has been picked by the acceptors for the current ballot, but this is not necessarily the case since, in the case of a leader failure, new leaders are not guaranteed to be aware of the latest round. To further complicate the problem, since fast ballots allow multiple values to be concurrently proposed, the acceptors can relay different values voted for in the previous ballot. If for a ballot $k$ some value $v$ has already been sent by a previous leader to the acceptors such that a majority voted for it, no other value will be accepted. Lamport states that~\cite{Lamport2006}:\par

\begin{displayquote}
	\textbf{Observation 4.} (...) a value $v$ has been or might yet be chosen in round $k$ only if there exists a $k$-quorum $R$ such that $vr(a)=k$ and $vv(a)=v$ for every acceptor in $R \cap Q$.
\end{displayquote}

To determine what the leader's behavior needs to be when picking a value, it's useful to think about what actions are available when it has gathered $Q$:
\begin{itemize}
	\item If no value satisfies Obs. 4 then no value is guaranteed to have been picked. In this case, the leader can choose any value present in the \textit{phase 1b} messages.
	\item If one value $v$ satisfies Obs. 4 then that value is the only value that has been or might yet be picked in round $k$ and the leader can only pick $v$ in \textit{phase 2a}.
	\item If there is more than one value that satisfies Obs. 4, then the leader has no way of choosing a value.
\end{itemize} 

Lamport solves this problem by making the third case impossible. He does this by noticing that this case requires Obs. 4 to be true for two distinct values $v$ and $w$, which implies that there are $k$-quorums $R_v$ and $R_w$ such that every acceptor in $R_v \cap Q$ has voted for $v$ and every acceptor in $R_w \cap Q$ has voted for $w$. This becomes impossible if we force $R_v \cap R_w \cap Q \neq \emptyset$. This rule is formalized as:

\begin{displayquote}
	\textbf{Quorum Requirement} For any round numbers $j$ and $i$:\par
	(a) Any $i$-quorum and any $j$-quorum have a non-empty intersection.\par
	(b) If $j$ is a fast round number, then any $i$-quorum and any two $j$-quorums have non-empty intersection. 	
\end{displayquote}

The system and quorums sizes can then be defined with respect to parameters $f$ and $e$, respectively, the maximum number of faults the system can tolerate while still being able to function correctly and the maximum number of faults the system can tolerate while still being able to support two step executions. The system size $N$ must take into account the following restrictions: $N > 2f$ and $N > 2e+f$. If we wish to always allow fast executions then $e=f$ and the minimum value of $N$ becomes $3f+1$. Similarly, the fast and classic quorums both become $N-e=N-f= 2f+1$. This is the cost imposed on the system in order to allow the safe learning of values in two message steps at any moment. {\color{red}Another alternative would be to minimize $e$ such that two step executions are only possible while the system doesn't experience faults (i.e., $e=0$). In this case, the strictest restriction on system size is $N>2f$. However, even though the size of a classic quorum would be only $f+1$, a fast quorum would have to contact every process in the system.\par}