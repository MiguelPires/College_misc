%\subsection{Description}
This section presents our Byzantine fault tolerant Generalized Paxos
Protocol (or BGP, for short). Given our space constraints, we opted
for merging in a single description a novel presentation of
Generalized Paxos and its extension to the Byzantine model.
\subsection{Overview}

We modularize our protocol explanation according to the following main components, which are also present in other protocols of the Paxos family:

\begin{itemize}

\item
  {\bf View change} -- The goal of this subprotocol is to ensure that, at any given moment, one of the proposers is chosen as a distinguished leader, who runs an extended version of the agreement subprotocol. To achieve this, the view change subprotocol continuously replaces leaders, until one is found that can ensure progress (i.e., commands are eventually appended to the current sequence).

\item
{\bf Agreement} -- Given a fixed leader, this subprotocol extends the current sequence with a new command or set of commands. Analogously to Fast Paxos~\cite{L06} and Generalized Paxos~\cite{Lamport2005}, choosing this extension can be done using two variants of the protocol: using either {\bf classic ballots} or {\bf fast ballots}, with the characteristic that fast ballots complete in fewer communication steps, but may have to fall back to using a classic ballot when there is contention among concurrent requests.

\end{itemize}

\subsection{View change} 

The goal of the view change subprotocol is to elect a distinguished acceptor process, called the leader, who is responsible for carrying through the agreement protocol, i.e., who enables proposed commands to eventually be learned by all the learners. The overall design of this subprotocol is similar to the corresponding part of existing BFT state machine replication protocols~\cite{CL99}.

In this subprotocol, the system moves through sequentially numbered views, and the leader for each view is chosen in a rotating fashion using the simple equation $\textit{leader(view)}=\textit{view mod N}$. The basic idea of this subprotocol is that acceptor processes monitor whether progress is being made on adding commands to the current sequence, and, if not, they send a message to other acceptors suspecting the current leader. If enough suspicions are collected, processes can move to the subsequent view.

In more detail, whenever an acceptor process individually perceives that liveness is not being upheld (i.e., there are pending commands that have not gathered enough support to conclude their execution, as detailed next), it starts suspecting the leader and multicasts a signed {\sc suspicion} message for the current view to all acceptors.

To ensure that $f$ Byzantine processes cannot trigger view changes by producing  false suspicions, acceptor processes only send a view change message indicating their commitment to starting a new view after hearing that $f+1$ processes suspect the leader to be faulty. In particular, at this point, acceptor processes multicast a view-change message containing the new view number, the $f+1$ signed suspicions, and signed proof that the acceptor sent the view-change message for the new view number. If a process receives a view-change message without previously receiving $f+1$ suspicions, it can also multicast a view-change message, after verifying that the suspicions are correctly signed by $f+1$ distinct processes.
%As such, the signatures allow a process that receives this message to commit to the new view and multicast its own view-change message without receiving $f+1$ suspicions itself.
This guarantees that if one correct process receives the $f+1$ suspicions and broadcasts the view-change message, then all correct processes, upon receiving this message, will be able to validate the proof of $f+1$ suspicions and also multicast the view-change message.


Finally, an acceptor process must wait for $N-f$ view-change messages to start participating in the new view, i.e., update its view number and the corresponding leader process. The acceptor also gathers proofs that others are committing to the new view, in order to send them to the new leader once he gathers $N-f$ valid view-change messages. As such, a leader can start coordinating a new view once he validates the $N-f$ signatures contained in a single acceptor's message.

\subsection{Agreement protocol} 

The consensus protocol allows learner processes to agree on equivalent sequences of commands (according to our previous definition of equivalence).
An important conceptual distinction between the original Paxos protocol and BGP is that, in the original Paxos, each instance of consensus is called a ballot, whereas in BGP, instead of being a separate instance of consensus, 
ballots correspond to an extension to the sequence of learned commands of a single ongoing consensus instance.
In both protocols, ballots can either be \textit{classic} or \textit{fast}. 


In classic ballots, a leader proposes a single sequence of commands, such that it can be appended to the commands learned by the learners. 
A classic ballot in Generalized Paxos follows a protocol that is very similar to the one used by classic Paxos~\cite{Lam98}. This protocol comprises a first phase where each acceptor conveys to the leader the sequences that the acceptor has already voted for (so that the leader can resend commands that may not have gathered enough votes). In classic Paxos, the first phase also allows the leader to obtain promises that the acceptors will not vote in an lower-numbered ballot. However, in BGP this promise is already implicit, since there is only one leader per view and it's the only process allowed to propose in a classic ballot. This is followed by a second phase where the leader picks an extension to the sequence of previously proposed commands and broadcasts it to the acceptors. The acceptors send their votes to the learners, who, after gathering enough support for a given extension to the current sequence, append the new commands to their own sequences of learned commands.

In fast ballots, multiple proposers can concurrently propose either single commands or sequences of commands by sending them directly to the acceptors. (We use the term \textit{proposal} to denote either the command or sequence of commands that was proposed.)
In this case, concurrency implies that acceptors may receive proposals in a different order. If the resulting sequences are equivalent, then the fast ballots are successfully learned in two message delays. If not, the protocol must fall back to using a classic ballot.

Next, we present the protocol for each type of ballot in detail.

\subsection{Classic ballots} 

Classic ballots work in a way that is very close to the original Paxos protocol~\cite{Lam98}. Therefore, throughout our description, we will highlight the points where BGP departs from that original protocol, either due to the Byzantine fault model, or due to the weaker specification of Generalized Paxos.

A continuous processing that the leader process has to do is to collect proposals. In particular, proposers send their proposed commands to the leader, who assembles them in a sequence. This sequence is built by appending newly received proposals to a sequence containing every proposal received since the previous ballot. (This differs from classic Paxos, where it suffices to keep a single proposed value that the leader attempts to reach agreement on.)

When the next ballot is triggered, the leader starts the first phase by sending phase $1a$ messages to all acceptors containing just the ballot number. Similarly to classic Paxos, acceptors reply with a phase $1b$ message to the leader, which reports the highest ballot they participated in, and all sequences of commands they voted for. In classic Paxos, acceptors also promise not to participate in lower-numbered ballots, which is important to prevent safety violations~\cite{Lam98}. However, in BGP this promise is implicit since only the leader can propose new ballots and at any moment there is only one such leader.

Upon receiving phase $1b$ messages, the leader validates that the commands were proposed by valid proposers, and not created by faulty acceptors, by validating command signatures. (This is needed due to the Byzantine model.)  After gathering a quorum of $N-f$ responses, the leader initiates phase $2a$ by sending a message with a proposal to the acceptors (as in the original protocol, but with a quorum size adjusted for the Byzantine model). This proposal is assembled by appending the sequence assembled from the proposers to a sequence that contains every command in the sequences that were previously accepted by the acceptors in the quorum (instead of sending a single value with the highest ballot number in the classic specification).

The acceptors reply to phase $2a$ messages by sending phase $2b$ messages to the learners, containing the ballot and the proposal from the leader. After receiving $N-f$ votes for a sequence, a learner learns it by extracting the commands that are not contained in his $learned$ sequence and appending them in order. (This differs from the original protocol in the quorum size, due to the fault model, and by the fact that learners would wait for a quorum of matching values, due to the specification of agreeing on a single value.)

\subsection{Fast ballots} 
To initiate a fast ballot, the leader informs both proposers and acceptors that the proposals may be sent directly to the acceptors. Unlike classic ballots, where the sequence proposed by the leader consists of the commands received from the proposers appended to previously proposed commands, in a fast ballot, proposals can be sent to the acceptors in the form of either a single command or a sequence to be appended to the command history. These proposals are sent directly from the proposers to the acceptors, who then append them to the proposals they have previously accepted in the current ballot and broadcast the result to the learners. Like in the classic ballot, the phase $2b$ message sent to the learners contains the current ballot number and the command sequence. To learn a sequence, the learner must gather $N-f$ votes for equivalent sequences. That is, sequences don't necessarily have to be equal to be learned since commutative commands may be reordered. Recall that a sequence is equivalent to another if it can be transformed into the second one by reordering its elements without changing the order of any pair of non-commutative commands. (Note that, in the pseudocode, equivalent sequences are being treated as belonging to the same index of the \emph{messages} variable, to simplify the presentation.) \par
\textbf{Leader Value Picking.} Sequences sent by the acceptors in phase $1b$ messages may contain commands that were not learned. This is likely if, in a fast ballot, non-commutative commands are  concurrently proposed by proposers. In this situation, these commands may be incorporated into the sequences of various acceptors in different orders, and therefore the sequences sent by the acceptors in phase $2b$ messages will not be equivalent and will not be learned. However, after the leader gathers these unlearned sequences in phase $1b$, it will assemble a single serialization for every previously proposed command, which it will then send to the acceptors. Therefore, if non-commutative commands are concurrently proposed in a fast ballot, they will be included in the subsequent classic ballot and the learners will learn them in a total order, preserving consistency.

\iffalse 
\subsection{Optimization: Integration with view changes}

{\bf [Just a paste of two previous paragraphs -- need to organize this subsection]}

 This first phase becomes unnecessary when a classic ballot is executed after a view change, since the view change protocol can include this first phase, i.e., it can gather previously committed sequences and extract that same promise from the acceptors. In this case, the aforementioned promise is implicitly valid because, for the remainder of the current view, the leader is the only process that can start a new ballot.

 Note that there is a subtle interplay between the two types of ballots, since the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot. This is because the acceptors may have used a fast round to vote for new sequences that are unknown to the leader, since they were proposed directly by the proposers.
\fi
