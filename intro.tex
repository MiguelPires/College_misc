
\chapter{Introduction}
\section{Motivation}
The consensus problem requires that processes agree on proposed values in the presence of $f$ faults and its solution has been essential to solve many distributed computing problems. This problem can be specified through two safety conditions and a liveness one, respectively \cite{vukolic2012quorum}: \par
\textbf{Agreement} No two processes learn different values\par 
\textbf{Validity} If a process learned a value $v$, then some process proposed $v$\par
\textbf{Termination} Every process learns a value in a finite number of steps\par
One of the most important contributions to this field is the Fischer, Lynch and Patterson (FLP) impossibility result that states that the \textit{wait-free} consensus problem is unsolvable in an asynchronous system even if only one process can fail \cite{Fischer1985}. Lamport's Paxos algorithm is able to solve consensus, circumventing the FLP impossibility result, by ensuring that values are always safely decided while progress is only guaranteed when the system is synchronous for a sufficient amount of time \cite{Lamport2001}. In other words, Paxos overcomes the FLP result by weakening the liveness condition since it can't guarantee that correct processes will decide a value in a finite number of steps. In Paxos, there are 3 types of processes: \textit{proposers}, which propose values to be committed; \textit{acceptors}, which vote on proposed values; and \textit{learners}, that learn values voted on by a quorum of acceptors (i.e., committed). This problem has gone from a theoretical exercise to a fundamental part of many large-scale, modern distributed systems such as Google's Chubby \cite{Burrows2006}, Spanner \cite{Corbett2012} and Apache's ZooKeeper \cite{Junqueira2011}. These systems power services like the Google Search Engine, using techniques like state machine replication (SMR) to allow them to remain highly available even in the presence of faults and asynchronous communication channels. SMR implements a fault tolerant system by modeling its processes as state machines that must receive the same inputs, execute the same state transitions and output the same results. Usually, to ensure that every state machine transitions to the same states, consensus is used to guarantee that inputs are processed in the same order. This technique is widely used to implement fault tolerant services and it's one of the reasons why consensus is so important.\par
Generalized consensus is a generalization of traditional consensus that abstracts the problem of agreeing on a single value to a problem of agreeing on a monotonically increasing set of values. This problem is defined in terms of a set of values called command structures, \textit{c-structs} \cite{Lamport2005}. These structures allow for the formulation of different consensus problems, including consensus problems where commutative operations are allowed to be ordered differently at different replicas (i.e., command histories). The advantage of such a problem can be seen in Fast Paxos, where fast ballots are executed by having proposers propose directly to acceptors \cite{Lamport2006}. By avoiding sending the proposal to the leader, values can be learned in the optimal number of two message delays. However, if two proposers concurrently propose different values to acceptors, a conflict arises and at least an additional message delay is required for the leader to solve it. This is the cost that Fast Paxos pays in order to commit values in a single round trip.  Generalized consensus allows us to reduce this cost, if we define the problem as one of agreeing on command histories. Since histories are considered equivalent if non-commutative operations are totally ordered, the only operations that force the leader to intervene are non-commutative ones. An additional advantage of the generalized consensus formulation stems from its generality and from the fact that we can use the Generalized Paxos protocol to solve it despite its high level of abstraction. This protocol can be used to solve any consensus problem that can be defined in terms of generalized consensus, not only the command history problem. The reason why Generalized Paxos can take advantage of the possibility of reordering commutative commands is that it allows acceptors to accept different but compatible \textit{c-structs}. Two \textit{c-structs} are considered to be compatible if they can later be extended to equivalent \textit{c-structs}. In command histories, if all non-commutative commands are totally ordered, then two \textit{c-structs} are considered equivalent. \par
One application of the generalized consensus specification can be to implement SMR using command histories to agree on equivalent sequences of operations. For instance, consider a system with four operations $\{A, B, C, D\}$ where $C$ and $D$ are non-commutative. If two proposers concurrently propose the operations $A$ and $B$, some acceptors could accept $A$ first and then $B$ and other acceptors could accept the operations in the inverse order. However, this would not be considered a conflict and the leader wouldn't have to intervene since the operations commute. If two proposers tried to commit $C$ and $D$, acceptors could accept them in different orders which would be considered a conflict since these operations are non-commutative. In this situation, no \textit{c-struct} would be chosen and the leader would be forced to intervene by initiating a higher-numbered ballot to commit either $w \bullet C \bullet D$ or $w \bullet D \bullet C$. It's important to note that this is only one possible application of the Generalized Paxos protocol and that this protocol solves any problem that can be defined by the generalized consensus specification. \par
The approach of allowing the system to reorder operations may feel familiar to the reader, since it resembles how weak consistency models relax consistency guarantees to allow replicas to reorder operations \cite{Ladin1992}. By relaxing consistency and allowing operations to be reordered, these models reduce coordination requirements which results in decreased latency and better operation concurrency. However, relaxing consistency guarantees also introduces the chance of state divergence which can be tolerable or not depending on the application. These approaches are critical to geo-replicated scenarios where it's important to reduce round trips between data centers and maintaining strong consistency incurs in an unacceptable latency cost. \par
The Paxos protocol family has been a subject of study for some time, due to its importance in the area of consensus and state machine replication. Recent work in this area includes Mencius \cite{Mao2008} and EPaxos \cite{Moraru2013}, which try to increase throughput by eliminating the bottleneck caused by having a single leader that sends proposals to acceptors. The Generalized Paxos protocol is similar to these approaches in the sense that it also decreases the load put on the leader by allowing proposers to bypass it. However, despite generalized consensus' potential, it's still an understudied problem and its formulation is rather complex and abstract which makes it hard to understand and reason about. This complexity also makes the algorithm hard to implement and adapt to different scenarios. A symptom of this is that only the original Generalized Paxos protocol exists for this problem and few works make use of it.  \par
Another consequence of the lack of knowledge about generalized consensus is that there are several potentially interesting research questions that researchers haven't answered. For instance, despite the connection between the commutativity observation that motivated generalized consensus and the reduced coordination requirements made possible by weak consistency, it is unclear how Generalized Paxos would function in geo-replicated scenarios where the goal is to minimize cross-datacenter round trips. The goal of Generalized Paxos is to reduce communication steps without requiring a leader to solve conflicts that emerge from concurrently executed operations but few works have tried to align this algorithm with a multi-datacenter scenario. Similarly, there is not much research on what effects the Byzantine assumption would have on the solution of the generalized consensus problem.
\par

\section{Contributions}
The goal of this work is to perform a thorough study of the generalized consensus problem to gain a deeper knowledge about the applicable protocols, such as Generalized Paxos, and how they behave in different scenarios. One of the greatest barriers in the comprehension and adoption of Generalized Paxos, is the complexity of its description which, in turn, is cause by a very general and complex description of generalized consensus. Therefore, as our first contribution, we simplify the problem specification from the full generalized consensus to a simpler specification that preserves the motivating scenario. This consensus problem is known as the command history problem and consists in agreeing on sequences of commands where sequences are considered equivalent if all non-commutative operations are totally ordered. \par
In order to perform this study, Generalized Paxos was adapted to several models while still preserving the advantageous properties which motivated its creation. The first version of the protocol starts by adapting the original protocol to the more specific consensus problem of command histories in the crash fault model. The second version of the protocol, Byzantine Generalized Paxos (BGP), solves the same problem in the Byzantine fault model. Lastly, the third version of the protocol, adapts Generalized Paxos to the Visigoth fault model \cite{Porto2015}, where the fault and synchrony assumptions are parameterizable in order to allow for any amount of synchrony, ranging from full asynchrony to full synchrony, and any amount of Byzantine or crash faults, allowing the system to support any combination of faults within the spectrum between crash and Byzantine faults. With this model we can study command history consensus from different perspectives and propose a solution that allows it to be solved across a broad spectrum of system models. This is an important aspect because, although it adds complexity, it adds the ability to develop a generic protocol that can be used in different environments. As such, this work removes some generality of the problem specification while retaining the original motivating scenario but, in turn, generalizes the model, allowing the system administrator to tune the protocol.  One particularly interesting application is similar to that of weakly consistent systems and geo-replicated datacenters. By specifying a consensus problem akin to command histories, our protocol could take advantage of operation commutativity to minimize the number of ballots that incur in a higher coordination cost. In this scenario, the parameterizability of Visigoth model also plays an important role since we can specify a number of slow processes that allows us to reduce the number of replicas that are required to safely commit values. Another potentially interesting scenario, related to the fault model, could be one where we tolerate arbitrary, uncorrelated faults. This is an interesting scenario since it's enough to deal with arbitrary state corruption faults, which are common within datacenters \cite{AmazonS32}, but avoids the cost of dealing with coordinated Byzantine behavior.\par 
In addition to these contributions, a checkpointing sub-protocol is also proposed to manage the accumulation of data at the acceptor processes and an optimization is proposed that reduces quorums requirements for certain sequences of commands at no additional cost.
{\color{red}An alternative approach is to give replicas weights according to their connectivity and performance. Since replicas with better hardware and network connectivity have better performance and reliability, they can be given a higher weight to allow for quorums to be formed with a lower number of higher quality replicas. This approach is used in WHEAT (WeigHt-Enabled Active replicaTion) to reduce latency \cite{Sousa2016}}.  \todo{Professor Alysson mentioned WHEAT, should I include this?}

\section{Document Outline}

The remainder of this document is structured as follows: Section 2 is divided in five subsections and surveys works that are related to our own and may provide relevant insights into the problem we're trying to solve. Each subsection describes scientific works in a specific area of interest to us. Section 3.1 describes what we have accomplished so far regarding the solution to generalized consensus in the Visigoth model. Section 3.2 proposes how these preliminary results should be extended to arrive at the final solution. Section 3.3 describes how the developed solution will be validated. Section 3.4 proposes a schedule for the development, implementation, validation and documentation of future work.
