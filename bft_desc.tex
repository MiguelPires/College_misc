\subsection{Description}
We now present the adapted Generalized Paxos protocol for a Byzantine adversary.\par
\textbf{View Change} The goal of the view change sub-protocol is to ensure that when $f+1$ processes suspect the leader to be faulty all correct processes commit to a new view and stop participating in lower-numbered views. To this end, processes can multicast suspicion messages if they believe that the leader is faulty. Suspicions contain the current view number, signed by the sending process in a verifiable way. This signature is the digest of sender's identification and current view number, encrypted by the suspecting process's private key. If a correct process receives $f+1$ suspicions, it stops participating in the previous view and multicasts a view-change message. View-change messages contain a ballot number, the previously committed ballot and value, and the $f+1$ suspicions, including the signature. If a process receives a view-change message without previously receiving $f+1$ suspicions, it can verify the suspicions, commits to the new view and multicasts a view-change message. The signature allows a process that receives this message to commit to the new view and multicast its own view-change messages without receiving $f+1$ suspicions itself. The process must only confirm that the signatures are valid and correspond to suspicions sent by distinct processes for the current view. This guarantees that if one correct process received the $f+1$ suspicions and broadcasted the view-change message, then all correct processes will receive that message, validate the proof of $f+1$ suspicions and switch to the new view. Processes start participating in the new view as soon as they broadcast their view-change messages, since the multicast of one correct view-change message is all it takes to ensure that all correct process will eventually switch to the new view. The only process that must wait for $2f+1$ view-change messages is the leader of the new view since, to send new sequences, it needs to know the values voted for in the last ballot for a quorum of acceptors. \par
\textbf{View Change Proof} We can prove that $f+1$ suspicions trigger a new view successfully since as soon as one process receives those suspicions it will broadcast a view-change message containing a proof that $f+1$ processes suspect the leader. When other processes receive either the $f+1$ suspicions or the view-change message, they will broadcast their own view-change messages and start participating in the new view. Faulty processes alone can't force a new view since $f+1$ suspicions are required for any correct process to commit to the new view.\par
\textbf{Agreement Protocol} The consensus protocol allows processes to agree on equivalent sequences of commands. Each consensus instance is called a ballot, which can be \textit{classic} or \textit{fast}. In classic ballots, a leader proposes a single sequence of commands which is learned by the learners. In fast ballots, multiple proposers can concurrently propose either single commands or sequences of commands to acceptors which send their votes to learners. We use the terms \textit{value} or \textit{proposal} to denote a proposer's proposed command or sequence. Concurrency implies that acceptors may send votes in different orders but the protocol ensures that, as long as the resulting sequences are equivalent, the commands will be learned in two message delays. A classic ballot in Generalized Paxos contains a first phase where the leader obtains a promise that the acceptors will not participate in lower-numbered ballots and the sequence that the acceptor voted for. This first phase becomes unnecessary when a classic ballot is executed after the view change, since the leader already gathered the last committed sequences and no promise is required from the acceptors. The leader doesn't need to ask the acceptors not to participate in lower-numbered ballots because, for the remainder of the current view, the leader is the only process that can start a new ballot. \todo{Is there any problem if an acceptor receives an accept message out-of-order? I believe not} However, the leader must execute the first phase if he wishes to run a classic ballot after a fast ballot, since the acceptors may have voted for new sequences unknown to the leader since they were proposed directly by the proposers. \par
\textbf{Classic Ballots} In a classic ballot, proposers send their proposed commands to the leader who sends a single sequence of commands to the acceptors. This sequence is built by appending the new proposals to the longest sequence committed in the previous ballot. The leader starts by sending phase $1a$ messages to acceptors, which respond with the last ballot in which they voted, the sequence of commands they voted for and cryptographic signatures of $N-f$ acceptors for each accepted value included in the sequence. We defer the discussion of how the previously committed sequence is determined until we have described fast ballots. After assembling the proposal, the leader initiates phase $2a$ by sending a message with the proposal to the acceptors. Upon receiving the proposal, the acceptor computes a cryptographic proof, verifiable by any acceptor, that it will vote for the proposal in the current ballot. This proof is signing the pair $\langle ballot,value \rangle$ with the acceptor's private key. After computing the digital signature, the acceptor broadcasts it along with the ballot and value to the other acceptors. Every acceptor waits for $N-f$ such messages that contain correct signatures for the same ballot and proposal. After a quorum of verification messages has been reached, the acceptor sends a phase $2b$ message to the learners, containing the ballot, the value and certificates proving that $N-f$ vote for the same value. By sending these proofs, a learner only needs to receive a phase $2b$ message from a single acceptor to know that a quorum of acceptor has voted for it and every learner will learn it. \par
\textbf{Fast Ballots} To initiate a fast ballot, the leader broadcasts an \textit{any} value to inform proposers that they may propose directly to the acceptors. Unlike classic ballots, where a leader's proposed sequence consists of commands sent by the proposers appended to the sequence of already learned commands, in a fast ballot, proposals can be sent to the acceptors in the form of either a single command or a sequence to be appended to the command history. These proposals are sent directly from the proposers to the acceptors which verify that each commands commutes with every other command proposed on the same ballot. If no conflict is detected, the acceptor computes a signature that proves his intent to vote for the proposal and broadcasts it to all acceptors. Upon receiving such a verification message, an acceptor verifies the proof, checks if the proposal commutes with every other proposed command and, after receiving $N-f$ such messages, it sends a phase $2b$ message to the learners. The command must be check for commutativity with the other known proposals both at before sending and after receiving a verification message because, not only can an acceptor receive a command that is non-commutative with some other command it may have been previously received, but also it may receive the verification messages of $N-f$ acceptors before actually receiving the proposal itself. This ensures that no two non-commutative commands are accepted in the same ballot and, therefore, the learned sequences are equivalent. However, in the case that two non-commutative proposals are concurrently received, it's possible that neither one of them is accepted. Like in the classic ballot, the phase $2b$ message sent to the learners contains the current ballot number, the proposed command and the $N-f$ certificates proving that $N-f$ acceptors agreed to vote for it. Since the proofs are sent along with the proposal, a learner only needs to receive one phase $2b$ message and verify the cryptographic signatures sent with the values before learning the command.\par
\textbf{Verification Round Proof} 
The additional broadcast round between acceptors assures us of two things: (1) A correct acceptor only sends its vote to the learners after being able to prove to another process that $N-f$ acceptors voted for the value; (2) A correct acceptor only sends its vote to the learners when $N-f$ acceptors have agreed that the proposed command commutes with every other proposal received in the same ballot. Therefore, the command can be learned without any change of consistency being violated. If the acceptor sent non-commutative commands in phase $2b$ messages to the learners, the messages could be reordered while in-transit and end up being learned in different orders at different learners. If non-commutative commands are not totally ordered then the consistency would be violated and consensus wouldn't be reached. \par
\textbf{Leader Value Picking} Previously, we postponed the discussion of how the leader picks a sequence because it is influenced by the verification round. To build a proposal the leader must wait for $N-f$ phase $1b$ messages containing a set of values accepted by the acceptor in the last ballot and certificates for those values. The leader rebuilds the sequence that the acceptor voted for by verifying each of the $N-f$ proofs for each value and appending those values to a sequence. When the leader contains $N-f$ such sequences, it is guaranteed to know about any value that may have been accepted in the previous ballot. Before sending its own proposal, the leader goes through the sequences assembled for each acceptor, building a sequence that is safe to extend by extracting every command from those sequences and appending it to the safe sequence exactly once. To avoid appending the same command more than once, commands must be uniquely identified. This can be done through the proposer's id and a sequence id, $\langle p_{id}, seq_{id}\rangle$. After going through $N-f$ accepted sequences, the resulting safe sequence contains every value learned in the previous ballot and can be safely extended with the leader's proposals without breaking stability.