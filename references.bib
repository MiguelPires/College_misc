@article{Renesse2011,
abstract = {This article explains the full reconfigurable multidecree Paxos (or multi-Paxos) protocol. Paxos is by no means a simple protocol, even though it is based on relatively simple invariants. We provide pseudocode and explain it guided by invariants. We initially avoid optimizations that complicate comprehension. Next we discuss liveness, list various optimizations that make the protocol practical, and present variants of the protocol.},
author = {van Renesse, Robbert},
doi = {10.1145/2673577},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/paxos.pdf:pdf},
issn = {15577341},
journal = {ACM Computing Surveys},
number = {3},
pages = {1--36},
title = {{Paxos Made Moderately Complex}},
volume = {47},
year = {2011}
}

@article{Lamport2006,
abstract = {As used in practice, traditional consensus algorithms require three message delays before any process can learn the chosen value. Fast Paxos is an extension of the classic Paxos algorithm that allows the value to be learned in two message delays. How and why the algorithm works are explained informally, and a TLA+ specification of the algorithm appears as an appendix.},
author = {Lamport, Leslie},
doi = {10.1007/s00446-006-0005-x},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/Fast Paxos.pdf:pdf},
isbn = {0178-2770},
issn = {01782770},
journal = {Distributed Computing},
keywords = {Consensus,Distributed algorithms,Fault tolerance,Paxos},
number = {2},
pages = {79--103},
title = {{Fast Paxos}},
volume = {19},
year = {2006}
}

@article{Lamport2005,
abstract = {The state-machine approach to implementing a fault-tolerant distributed system involves reaching agreement on the sequence of system commands by executing a sequence of separate instances of a consensus algorithm. It can be shown that any fault-tolerant asynchronous consensus algorithm re- quires at least two message delays between the issuing of a command and when it can be executed. But even in the absence of faults, no algorithm can guarantee this fast an execution if two different commands are issued concurrently. We generalize the state-machine approach to involve reach- ing agreement on a partially ordered set of commands. By generalizing the Paxos consensus algorithm, we can implement a system in which concur- rently issued commands can always be executed in two message delays if they are non-interfering, so it does not matter in which order those com- mands are executed. For many systems, concurrent commands are rarely interfering, so the generalized Paxos algorithm can be quite efficient. And command-structure sets are very simple.},
author = {Lamport, Leslie},
doi = {MSR-TR-2005-33},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/Generalized Paxos.pdf:pdf},
issn = {{\textless}null{\textgreater}},
number = {April},
pages = {60},
title = {{Generalized Consensus and Paxos}},
url = {http://research.microsoft.com/apps/pubs/default.aspx?id=64631},
year = {2005}
}

@article{Mao2008,
abstract = {We present a protocol for general state machine replication – a method that provides strong consistency – that has high performance in a wide-area network. In particular, our protocol Mencius has high throughput under high client load and lowlatency under lowclient load even under changing wide-area network environment and client load. We develop our protocol as a derivation from the well-known protocol Paxos. Such a development can be changed or further refined to take advantage of specific network or application requirements.},
author = {Mao, Yanhua and Junqueira, Flavio P. and Marzullo, Keith},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/mencius.pdf:pdf},
journal = {Proceedings of the Symposium on Operating System Design and Implementation},
pages = {369--384},
title = {{Mencius: Building Efficient Replicated State Machines for WANs}},
url = {https://www.usenix.org/legacy/events/osdi08/tech/full_papers/mao/mao.pdf},
year = {2008}
}

@article{Fischer1985,
abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
doi = {10.1145/3149.214121},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/jacm85.pdf:pdf},
isbn = {3-540-50840-6},
issn = {00045411},
journal = {Journal of the ACM},
number = {2},
pages = {374--382},
title = {{Impossibility of Distributed Consensus with One Faulty Process}},
url = {http://portal.acm.org/citation.cfm?doid=3149.214121},
volume = {32},
year = {1985}
}

@article{Lamport2001,
abstract = {The Paxos algorithm, when presented in plain English, is very simple.},
author = {Lamport, Leslie},
doi = {10.1145/568425.568433},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/paxos-simple.pdf:pdf},
isbn = {2-912590-26-4},
issn = {01635700},
journal = {ACM SIGACT news distributed computing column 5},
number = {4},
pages = {51--58},
title = {{Paxos Made Simple}},
url = {http://portal.acm.org/citation.cfm?doid=568425.568433},
volume = {32},
year = {2001}
}

@article{Lamport1982,
abstract = {Reliable computer systems must handle malfunctioning components that give conflicting information to different parts of the system. This situation can be expressed abstractly in terms of a group of generals of the Byzantine army camped with their troops around an enemy city. Communicating only by messenger, the generals must agree upon a common battle plan. However, one of more of them may be traitors who will try to confuse the others. The problem is to find an algorithm to ensure that the loyal generals will reach agreement. It is shown that, using only oral messages, this problem is solvable if and only if more than two-thirds of the generals are loyal; so a single traitor can confound two loyal generals. With unforgeable written messages, the problem is solvable for any number of generals and possible traitors. Applications of the solutions to reliable computer systems are then discussed.},
author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
doi = {10.1145/357172.357176},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/byz.pdf:pdf},
isbn = {0164-0925},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
number = {3},
pages = {382--401},
title = {{The Byzantine Generals Problem}},
volume = {4},
year = {1982}
}
@article{Castro1999,
abstract = {This paper describes a new replication algorithm that is able to tolerate Byzantine faults. We believe that Byzantine- fault-tolerant algorithms will be increasingly important in the future because malicious attacks and software errors are increasingly common and can cause faulty nodes to exhibit arbitrary behavior. Whereas previous algorithms assumed a synchronous system or were too slow to be used in practice, the algorithm described in this paper is practical: it works in asynchronous environments like the Internet and incorporates several important optimizations that improve the response time of previous algorithms by more than an order of magnitude. We implemented a Byzantine-fault-tolerant NFS service using our algorithm and measured its performance. The results show that our service is only3{\%}slower than a standard unreplicated NFS.},
author = {Castro, Miguel and Liskov, Barbara},
doi = {10.1145/571637.571640},
file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/PBFT.pdf:pdf},
isbn = {1-880446-39-1},
issn = {07342071},
journal = {Proceedings of the Symposium on Operating System Design and Implementation},
number = {February},
pages = {1--14},
pmid = {380302},
title = {{Practical Byzantine Fault Tolerance}},
url = {http://www.itu.dk/stud/speciale/bepjea/xwebtex/litt/practical-byzantine-fault-tolerant.pdf},
year = {1999}
}

@article{Liu2015,
	archivePrefix = {arXiv},
	arxivId = {arXiv:1502.05831v1},
	author = {Liu, Shengyun and Cachin, Christian and Quema, Vivien and Vukolic, Marko},
	eprint = {arXiv:1502.05831v1},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/XFT.pdf:pdf},
	pages = {1--32},
	title = {{XFT: Practical fault tolerance beyond crashes}},
	url = {http://arxiv.org/pdf/1502.05831v1.pdf},
	year = {2015}
}
@article{Ladin1992,
	abstract = {To provide high availability for services such as mail or bulletin boards, data must be replicated. One way to guarantee consistency of replicated data is to force service operations to occur in the same order at all sites, but this approach is expensive. ...},
	author = {Ladin, Rivka and Liskov, Barbara and Shrira, Liuba and Ghemawat, Sanjay},
	doi = {10.1145/138873.138877},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/gossip.pdf:pdf},
	issn = {07342071},
	journal = {ACM Transactions on Computer Systems},
	number = {4},
	pages = {360--391},
	title = {{Providing high availability using lazy replication}},
	volume = {10},
	year = {1992}
}

@article{Porto2015,
	abstract = {We present a new technique for designing distributed protocols for building reliable stateful services called Visigoth Fault Tolerance (VFT). VFT introduces the Visigoth model, which makes it possible to calibrate the timing assumptions of a system using a threshold of slow processes or messages, and also to distinguish between non-malicious arbitrary faults and correlated attack scenarios. This enables solutions that leverage the characteristics of data center systems, namely their secure environment and predictable performance, in order to allow replicated systems to be more efficient with respect to the utilization of resources than those designed under asynchrony and Byzantine assumptions, while avoiding the need to make a system synchronous, or to restrict failure modes to silent crashes. We implemented a VFT protocol for a state machine replication library, and ran several benchmarks. Our evaluation shows that VFT has comparable performance to existing schemes and brings significant benefits in terms of the throughput per dollar, i.e., the server cost for sustaining a certain level of request execution.},
	author = {Porto, Daniel and Leit{\~{a}}o, Jo{\~{a}}o and Li, Cheng and Clement, Allen and Kate, Aniket and Junqueira, Fl{\'{a}}vio and Rodrigues, Rodrigo},
	doi = {10.1145/2741948.2741979},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/vft{\_}eurosys15.pdf:pdf},
	isbn = {978-1-4503-3238-5},
	journal = {Proceedings of the Tenth European Conference on Computer Systems},
	pages = {8:1----8:14},
	title = {{Visigoth Fault Tolerance}},
	url = {http://doi.acm.org/10.1145/2741948.2741979},
	year = {2015}
}

@article{DeepakChandra1996,
	abstract = {We introduce the concept of unreliable failure detectors and study how they can be used to solve Consensus in asynchronous systems with crash failures. We characterise unreliable failure detectors in terms of two properties—completeness and accuracy. We show that Consensus can be solved even with unreliable failure detectors that make an infinite number of mistakes, and determine which ones can be used to solve Consensus despite any number of crashes, and which ones require a majority of correct processes. We prove that Consensus and Atomic Broadcast are redueible to each other in asynchronous systems with crash failures; thus, the above results also apply to Atomic Broadcast. A companion paper shows that one of the failure detectors introduced here is the weakest failure detector for solving Consensus.},
	archivePrefix = {arXiv},
	arxivId = {arXiv:1011.1669v3},
	author = {{Deepak Chandra}, Tushar and Thomas, tf J and Toueg, Sam and Chandra, Tushar Deepak and Toueg, Sam},
	doi = {10.1145/226643.226647},
	eprint = {arXiv:1011.1669v3},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/p225-chandra.pdf:pdf},
	isbn = {0897914392},
	issn = {00045411},
	journal = {Journal of the ACM},
	keywords = {3 [Programming Techniques],4 IDatabase Management],4 [Performance of Systems],Agreement problem,Algorithms,Byzantine Generals' problem,C,C24 [Computer-Communication Networks],Categories and Subject Descriptors,D1,Distributed Sys-tems—disoifsured applications,F 12 [Computation by Abstract Devices],F1l [Computation by Abstract Devices],H2,Models of Computation—automata,Modes of Computation—purallefism and concurrency,Reliability,Reliability+auft-f olerance,Systems—concurrency,Theory Additional Key Words and Phrases,and serviceability,asynchronous systems,atomic broadcast,availability,commit problem,consensus problem,crash failures,distributed databases,distributed systems,failure detection,fault-tolerance,message passing,network operating {\~{}}s(ems,partial synchrony,processor failures,rekzrions among models,reliability,transaction processing General Terms},
	number = {2},
	pages = {225--267},
	pmid = {25246403},
	title = {{Unreliable failure detectors for reliable distributed systems}},
	volume = {43},
	year = {1996}
}

@MISC{Guerraoui96gammaaccurate,
	author = {Rachid Guerraoui and Andre Schiper},
	title = {Gamma Accurate Failure Detectors},
	year = {1996}
}

@article{Chandra1996,
	abstract = {We determine what information about failures is necessary and sufficient to solve Consensus in asynchronous distributed systems subject to crash failures. Previously, we proved that W, a failure detector that provides surprisingly little information about which processes have crashed, is sufficient to solve Consensus in asynchronous systems with a majority of correct processes. In this paper, we prove that to solve Consensus, any failure detector has to provide at least as much information as W. Thus, W is indeed the weakest failure detector for solving Consensus in asynchronous systems with a majority of correct processes.},
	author = {Chandra, Tushar Deepak and Hadzilacos, Vassos and Toueg, Sam},
	doi = {10.1145/234533.234549},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/weakestFD.pdf:pdf},
	isbn = {0-89791-495-3},
	issn = {00045411},
	journal = {Journal of the ACM},
	keywords = {Byzantine Generals' problem,agreement problem,asynchronous systems,atomic broadcast,commit problem,consensus problem,crash failures,failure detection,fault-tolerance,message passing,partial synchrony,processor failures},
	number = {4},
	pages = {685----722},
	title = {{The Weakest Failure Detector for Solving Consensus}},
	url = {http://doi.acm.org/10.1145/234533.234549},
	volume = {43},
	year = {1996}
}

@article{Dijkstra1974,
	abstract = {Three studies examined the effect of primed psychological distance on level of perceptual construal, using Navon's paradigm of composite letters (global letters that are made of local letters). Relative to a control group, thinking of the more distant future (Study 1), about more distant spatial locations (Study 2), and about more distant social relations (Study 3) facilitated perception of global letters relative to local letters. Proximal times, spatial locations, and social relations had the opposite effect. The results are discussed within the framework of Construal Level Theory of psychological distance (Liberman {\&} Trope, 2008; Trope {\&} Liberman, 2003).},
	author = {Dijkstra, Edsger W},
	doi = {10.1145/361179.361202},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/self-stabilizing.pdf:pdf},
	isbn = {0001-0782},
	issn = {00010782},
	journal = {Communications of the ACM},
	keywords = {and phrases,distributed control,error recovery,harmonious cooperation,multiprocessing,mutual exclusion,networks,robustness,self-repair,self-stabilization,sharing,synchronization},
	number = {11},
	pages = {643--644},
	title = {{Self-stabilizing systems in spite of distributed control}},
	volume = {17},
	year = {1974}
}

@article{Kalbarczyk2003,
	abstract = {Not Available},
	author = {Kalbarczyk, Z. and Iyer, K.},
	doi = {10.1109/DSN.2003.1209956},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/e9ae8f1de1a2d7057fb7bf26a5b0567c67de.pdf:pdf},
	isbn = {0-7695-1952-0},
	journal = {2003 International Conference on Dependable Systems and Networks, 2003. Proceedings.},
	keywords = {Computer crashes,Delay,Failure analysis,File systems,Hardware,Kernel,Linux,Operating systems,Protection,Registers},
	number = {ii},
	pages = {459--468},
	title = {{Characterization of linux kernel behavior under errors}},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1209956},
	volume = {00},
	year = {2003}
}
@article{Correia2012,
	abstract = {Recent failures of production systems have highlighted the importance of tolerating faults beyond crashes. The industry has so far addressed this problem by hardening crash-tolerant systems with ad hoc error detection checks, potentially overlooking critical fault scenarios. We propose a generic and principled hardening technique for Arbitrary State Corruption (ASC) faults, which specifically model the effects of realistic data corruptions on distributed processes. Hardening does not require the use of trusted components or the replication of the process over multiple physical servers. We implemented a wrapper library to transparently harden distributed processes. To exercise our library and evaluate our technique, we obtained ASC-tolerant versions of Paxos, of a subset of the ZooKeeper API, and of an eventually consistent storage by implementing crash-tolerant protocols and automatically hardening them using our library. Our evaluation shows that the throughput of our ASC-hardened state machine replication outperforms its Byzantine-tolerant counterpart by up to 70{\%}.},
	author = {Correia, Miguel and Ferro, Daniel G{\'{o}}mez and Junqueira, Flavio P and Serafini, Marco},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/atc12-final190.pdf:pdf},
	isbn = {978-931971-93-5},
	journal = {Proceedings of the 2012 USENIX conference on Annual Technical Conference},
	pages = {41},
	title = {{Practical hardening of crash-tolerant systems}},
	url = {http://dl.acm.org/citation.cfm?id=2342821.2342862},
	year = {2012}
}

@article{Dwork1988,
	abstract = {The concept of partial synchrony in a distributed system is introduced. Partial synchrony lies between the cases of a synchronous system and an asynchronous system. In a synchronous system, there is a known fixed upper bound {\&}Dgr; on the time required for a message to be sent from one processor to another and a known fixed upper bound {\&}PHgr; on the relative speeds of different processors. In an asynchronous system no fixed upper bounds {\&}Dgr; and {\&}PHgr; exist. In one version of partial synchrony, fixed bounds {\&}Dgr; and {\&}PHgr; exist, but they are not known a priori. The problem is to design protocols that work correctly in the partially synchronous system regardless of the actual values of the bounds {\&}Dgr; and {\&}PHgr;. In another version of partial synchrony, the bounds are known, but are only guaranteed to hold starting at some unknown time T , and protocols must be designed to work correctly regardless of when time T occurs. Fault-tolerant consensus protocols are given for various cases of partial synchrony and various fault models. Lower bounds that show in most cases that our protocols are optimal with respect to the number of faults tolerated are also given. Our consensus protocols for partially synchronous processors use new protocols for fault-tolerant “distributed clocks” that allow partially synchronous processors to reach some approximately common notion of time.},
	author = {Dwork, Cynthia and Lynch, Nancy and Stockmeyer, Larry},
	doi = {10.1145/42282.42283},
	file = {:C$\backslash$:/Users/Miguel/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Jose - 1988 - Consensus in the Presence of Partial Synchrony.pdf:pdf},
	isbn = {0897911431},
	issn = {00045411},
	journal = {Journal of the ACM},
	number = {2},
	pages = {288----323},
	title = {{Consensus in the Presence of Partial Synchrony}},
	url = {http://doi.acm.org/10.1145/42282.42283},
	volume = {35},
	year = {1988}
}

@article{Dolev1983,
	abstract = {Reaching agreement is a primitive of distributed computing. While this poses no problem in an ideal, failure-free environment, it imposes certain constraints on the capabilities of an actual system: a system is viable only if it permits the existence of consensus protocols tolerant to some number of failures. Fischer, Lynch and Paterson [FLP] have shown that in a completely asynchronous model, even one failure cannot be tolerated. In this paper we extend their work, identifying several critical system parameters, including various synchronicity conditions, and examine how varying these affects the number of faults which can be tolerated. Our proofs expose general heuristic principles that explain why consensus is possible in certain models but not possible in others.},
	author = {Dolev, Danny and Dwork, Cynthia and Stockmeyer, Larry},
	doi = {10.1109/SFCS.1983.41},
	file = {:C$\backslash$:/Users/Miguel/Google Drive/Thesis/Papers/minimal{\_}synchronism.pdf:pdf},
	isbn = {0-8186-0508-1},
	issn = {0272-5428},
	journal = {24th Annual Symposium on Foundations of Computer Science (sfcs 1983)},
	number = {I},
	pages = {77--97},
	title = {{On the minimal synchronism needed for distributed consensus}},
	volume = {34},
	year = {1983}
}
