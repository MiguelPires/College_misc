\section{Protocol} 

This section presents our Visigoth fault tolerant Generalized Paxos protocol (\acrshort{vgp}). This protocol shares many similarities with \acrshort{bgp}. Instead of repeating the full protocol, we will describe its structure broadly while pointing differences introduced by \acrshort{vft}'s assumptions.  


\begin{algorithm}
	\caption{Visigoth Generalized Paxos - Proposer p}
	\label{VFT-Prop}
	\textbf{Local variables:} $ballot\_type = \bot$
	\begin{algorithmic}[1]	
		
		\State \textbf{upon} \textit{receive(BALLOT, type)} \textbf{do} 
		\State \hspace{\algorithmicindent} $ballot\_type = type$;
		\State
		
		\State \textbf{upon} \textit{command\_request(c)} \textbf{do}   \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}
		\State \hspace{\algorithmicindent} \textbf{if} $ballot\_type == fast\_ballot$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$P2A\_FAST, c$} to acceptors;
		\State \hspace{\algorithmicindent} \textbf{else} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{\textit{PROPOSE, c}} to leader;		
	\end{algorithmic}
\end{algorithm}

\subsection{Overview}
Much like the Visigoth model shares many similarities with the Byzantine model, our Visigoth Generalized Paxos protocol shares most of its structure and message pattern with \acrshort{bgp}, namely the following two components:
\begin{itemize}
	\item 
	\textbf{View-Change} -- The goal of the view-change subprotocol is to ensure that one of the proposers is elected as the leader, who helps the agreement protocol to make progress. If the current leader is perceived to be preventing progress, the acceptors share their suspicions with each other and, if enough suspicions are gathered, they elect a new leader. 
	
	\item 
	\textbf{Agreement} -- The goal of the agreement subprotocol is to extend the learners' learned sequence with commands proposed by the proposers. In order to do this, acceptors cast their votes in either \textit{classic} or \textit{fast} ballots, where fast ballots incur in fewer message steps but may run into contention among concurrent requests, requiring a subsequent classic ballot to fix the conflict.
\end{itemize}


\begin{algorithm} 
	\caption{Visigoth Generalized Paxos - Leader l}
	\label{VFT-Lead}
	\textbf{Local variables:} $ballot_l = 0,maxTried_l = \bot,proposals = \bot, accepted = \bot, notAccepted = \bot, view = 0$
	\begin{algorithmic}[1]
		\State \textbf{upon} \textit{receive($LEADER,view_a,proofs$)} from acceptor \textit{a} \textbf{do}
		\State \hspace{\algorithmicindent} $valid\_proofs = 0$;
		\State \hspace{\algorithmicindent} \textbf{for} $p$ \textbf{in} $acceptors$ \textbf{do} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $view\_proof = proofs[p]$;
		
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $view\_proof_{pub_p} == \langle view\_change, view_a \rangle$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}  $valid\_proofs \mathrel{+{=}} 1$;
		\State \hspace{\algorithmicindent} \textbf{if} $valid\_proofs > u$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $view = view_a$;
		
		\State
		\State \textbf{upon} \textit{trigger\_next\_ballot(type)} \textbf{do}
		\State \hspace{\algorithmicindent} $ballot_l \mathrel{+{=}} 1$;
		\State \hspace{\algorithmicindent} \Call{send}{$BALLOT,type}$ to proposers;
		\State \hspace{\algorithmicindent} \textbf{if} $type == fast$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$FAST,ballot_l,view}$ to acceptors;
		\State \hspace{\algorithmicindent} \textbf{else}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$P1A, ballot_l, view$} to acceptors;
		
		\State
		\State \textbf{upon} \textit{receive(PROPOSE, prop)} from proposer $p_i$ \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $\Call{isUniversallyCommutative}{prop}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{P2A\_CLASSIC, ballot_l,view, prop}$;
		\State \hspace{\algorithmicindent} \textbf{else}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proposals = proposals \bullet prop$;
		
		\State
		\State \textbf{upon} \textit{receive($P1B, ballot, bal_a, proven,val_a, proofs$)} from acceptor $a$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $ballot \neq ballot_l$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{return};
		\State
		\State \hspace{\algorithmicindent} $valid\_proofs = 0$; 
		\State \hspace{\algorithmicindent} \textbf{for} $i$ \textbf{in} $acceptors$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = proofs[proven][i]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof_{pub_i} == \langle bal_a, proven \rangle$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} 
		$valid\_proofs \mathrel{+{=}} 1$;
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $valid\_proofs > N-u$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $accepted[ballot_l][a] = proven$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}	$notAccepted[ballot_l] = notAccepted[ballot_l] \bullet (val_a \setminus proven)$;		
		
		\State 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $\#(accepted[ballot_l]) \geq N-u$ \textbf{then} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{phase\_2a}{$ $};
		
		\State
		\Function{phase\_2a}{$ $}
		\State $maxTried = \Call{largest\_seq}{accepted[ballot_l]}$;
		\State $previousProposals = \Call{remove\_duplicates}{notAccepted[ballot_l]}$;
		\State $maxTried = maxTried \bullet previousProposals \bullet proposals$;
		\State $\Call{send}{P2A\_CLASSIC,ballot_l,view, maxTried_l}$ to acceptors;
		\State $proposals = \bot$;
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}

Next, we describe solely the agreement subprotocol since it's the only one affected by the Visigoth model. The view-change subprotocol is identical to the one used in \acrfull{bgp}.

\subsection{Agreement}

\subsubsection{Message pattern}
Much like its Byzantine counterpart, \acrshort{vgp} preserves the original Fast Paxos message pattern. Proposers send their proposals to either the leader or the acceptors, depending on the type of ballot being currently executed. In fast ballots, proposers send their proposals directly to the acceptors, which broadcast their votes to other acceptors in a verification phase. This verification phase serves the same purpose as the analogous one in \acrshort{bgp}. Since the leader must be sure of exactly what sequences have been learned in order to propose sequences that are strict extensions of previously learned proposals, the acceptors must gather $N-f$ proofs from themselves and other acceptors in order to relay them in the next classic ballot's phase $1$. After gathering this quorum of proofs, acceptors send their votes and the corresponding proofs to the learners, who wait for a $N-f$ quorum of such messages before learning it. In classic ballots, the leader sends phase $1a$ messages requesting that acceptors respond with the largest sequence for which they have $N-f$ proofs. After receiving a quorum of such responses in phase $1b$ messages, the leader computes a sequence that is sure to be safe to be learned. This proposal is sent to the acceptors in phase $2a$ and contains both a proven prefix of commands and uncommitted proposals. After gathering a quorum of $N-f$ proofs, as in the fast ballots, the acceptors send phase $2b$ messages to the learners, relaying their votes.

\begin{algorithm} 
	\caption{Visigoth Generalized Paxos - Acceptor a (agreement)}
	\label{VFT-Acc}
	\textbf{Local variables:} $leader = \bot,\ view = 0, bal_a = 0,\ val_a = \bot,\ fast\_bal = \bot,\ proven = \bot$
	\begin{algorithmic}[1]
		\State \textbf{upon} \textit{receive($P1A, ballot, view_l$)} from leader $l$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $view_l == view$ and $bal_a < ballot$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{$P1B, ballot,bal_a,proven, val_a, proofs[bal_a]$} to leader;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $bal_a = ballot$;
		
		\State
		\State \textbf{upon} \textit{receive($FAST,ballot,view_l$)} from leader \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $view_l == view$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $fast\_bal[ballot] = true$;
		
		\State
		\State \textbf{upon} \textit{receive($P2A\_CLASSIC, ballot, view_l, value$)} from leader \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $view_l == view$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{phase\_2b\_classic}{$ballot, value$}; 
		
		\State		
		\State \textbf{upon} \textit{receive($P2A\_FAST, value$)} from proposer \textbf{do}
		\State \hspace{\algorithmicindent} \Call{phase\_2b\_fast}{$value$};
		
		\State
		\State \textbf{upon} \textit{receive($VERIFY,view_i, ballot_i,val_i,proof$)} from acceptor $i$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $proof_{pub_i} == \langle ballot_i, val_i \rangle$ or $view == view_i$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proofs[ballot_i][val_i][i] = proof$;
		
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $\#(proofs[ballot_i][val_i]) \geq N-u$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \hspace{\algorithmicindent} $proven = val_i$;
		\State \hspace{\algorithmicindent} \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{P2B, ballot_i, val_i, proofs[ballot_i][value_i]}$ to learners;

		\State		
		\State \textbf{upon} \textit{receive($VERIFY\_REQ, ballot_l, value_l$)} from learner $l$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $\#(proofs[ballot_l][value_l]) \geq N-u$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{VERIFY\_RESP, ballot, value, proofs[ballot_l][value_l]}$;

		\State
		\Function{phase\_2b\_classic}{$ballot, value$}
		\State $univ\_commut = \Call{isUniversallyCommutative}{val_a}$;
		\State \textbf{if} $ballot \geq bal_a$ and $!fast\_bal[bal_a]$ and ($univ\_commut$ or $proven == \bot$ or $proven == \Call{subsequence}{value, 0, \#(proven)}$) \textbf{then}
		\State \hspace{\algorithmicindent} $bal_a = ballot$;
		\State \hspace{\algorithmicindent} \textbf{if} $univ\_commut$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{P2B,bal_a, value}$ to learners;
		\State \hspace{\algorithmicindent} \textbf{else} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $val_a = value$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = \langle ballot, val_a \rangle_{priv_a}$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proofs[ballot][val_a][a] = proof$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{VERIFY, view, ballot, val_a, proof}$ to acceptors;
		\EndFunction
		
		\State
		\Function{phase\_2b\_fast}{$ballot, value$}
		\State \textbf{if} $ballot == bal_a$ and $fast\_bal[bal_a]$ \textbf{then}
		\State \hspace{\algorithmicindent} \textbf{if} $\Call{isUniversallyCommutative}{value}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $\Call{send}{P2B,bal_a, value}$ to learners;
		\State \hspace{\algorithmicindent} \textbf{else}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $val_a = val_a \bullet value$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = \langle ballot, val_a \rangle_{priv_a}$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proofs[ballot][val_a][a] = proof$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{send}{\textit{$VERIFY, view, ballot, val_a, proof$}} to acceptors;
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsubsection{Quorum gathering in VFT}
Note that until this point, the \acrshort{vgp} protocol seems entirely indistinguishable from its Byzantine counterpart. However, the improved latency showcased in \acrshort{vft}'s state machine replication protocol (VFT-SMaRt) is made possible by the Visigoth model's increased assumptions regarding process synchronism. These assumptions are neatly encapsulated in the \acrfull{qgp}, which implements the actions of gathering a quorum of messages for a given step of the protocol. Since these assumptions are encapsulated in a single primitive, it seems logical to simply substitute \acrshort{bgp}'s quorum gathering procedure with the \acrshort{qgp}. However, unlike the Fast and Generalized Paxos protocols, the VFT-SMaRt protocol doesn't specialize its algorithms by role, considering instead a system of $N$ identical processes~\cite{Porto2015}. Since we wish to preserve the role specialization present in Generalized Paxos, we must adapt VFT-SMaRt's quorum gathering procedure to a Paxos-like structure.\par
The Visigoth model differs from its Byzantine counterpart by allowing $s$ processes to be slow but correct \cite{Porto2015}. A process $i$ is defined to be slow with respect to $j$ if messages from $i$ to $j$ (or vice-versa) take more than $T$ time units to be transmitted. This assumption allows us to gather more efficient quorums by leveraging the knowledge that only $s$ processes can take more than $T$ time units to send and process a message. In \acrshort{vft}'s \acrfull{qgp}, a process gathers a quorum by waiting for messages from $N-s$ distinct processes. Since the Visigoth model provides a bound on the time messages from correct processes take to be transmitted, a gatherer process can set a timer that allows all correct and non-slow  messages to be delivered. After a timeout occurs, of the $x$ processes that are unresponsive, only $s$ of them may be slow, which means that $x-s$ processes must be faulty (recall that we consider only the case when $u>s$). This allows us to leverage the assumption of $s$ slow but correct processes to decrease the quorum size to $N-u$ while still guaranteeing the intersection properties necessary for safety. We make use of this mechanism to adapt our \acrlong{bgp} protocol to the Visigoth fault model. This includes changing the quorum gathering in phase $1b$, where acceptors relay their previous votes to the leader, in the verification phase, where acceptors exchange cryptographic proofs, and phase $2b$, where acceptors send their votes to the learners. \par
In our previous implementation of the Byzantine Generalized Paxos protocol, the nature of the consensus problem combined with the possibility of faults required altering the message pattern to contain an additional broadcast round. In the Visigoth model, this broadcast round serves a new purpose in addition to the gathering of proofs. In Byzantine Generalized Paxos, a Byzantine leader can at most prevent progress until a new leader is elected. Even if a leader causes a split vote by sending different values to some acceptors in its phase $2a$ messages, at most one of those values can obtain the $N-u$ votes required to be learned. However, since in the Visigoth model we want to take advantage of the additional assumptions to reduce the quorum to $N-u$, it becomes possible for the leader to attempt a split vote by sending two different values to two sets of acceptors and ignoring others such that the ignored acceptors are more than $s$ and the timeout is reached, causing the required quorum size to be reduced. Since $o$ of the remaining acceptors can behave arbitrarily and vote for both values and the leader could attempt a split vote between the remaining $u+s+1$ (including the acceptors that were previously ignored), there are enough votes for both values to be committed, violating the safety property. One configuration where this would happen would be with $u=o=2,\ s=1,\ N=u+o+\min(u,s)+1=6$. In this system the initial quorum is $N-s=5$ and the reduced quorum is $N-u=4$. If the leader sends $v_1$ to two acceptors (one correct and one faulty), $v_2$ to other two (also one correct and one faulty) and ignores the last two, then the timeout is reached and the required quorum size is reduced from 5 to 4. In this case, each value has two votes from both of the Byzantine acceptors and one vote from one of the two correct acceptors that received the split vote. Since the previously ignored acceptors are correct, the leader can employ another split vote to divide them between $v_1$ and $v_2$ to achieve four votes for both values. \par
To prevent this situation, when sending phase $2b$ messages to learners, acceptors must also replay the leader's phase $2a$ message to all other acceptors. This prevents the leader from purposely ignoring acceptors to force the quorum to decrease. To ensure that this replayed message originated from the leader and not from a Byzantine acceptor, it must include the leader's signature. If an acceptor, that hasn't received a phase $2a$ message from the leader, receives $f+1$ verifications from other acceptors, it validates that the signature originated from the leader and executes the action it would upon receival of a leader's phase $2a$ message.


\algnewcommand{\parState}[1]{\State%
	\parbox[t]{\dimexpr\linewidth-\algmargin}{\strut #1\strut}}
\begin{algorithm}
	\caption{Visigoth Generalized Paxos - Learner l}
	\label{VFT-Learn}
	\textbf{Local variables:} $learned = \bot,\ storedProofs = \bot,\ quorumSize = \bot,\ verificationMessages = \bot, validVotes = \bot$ 
	\begin{algorithmic}[1]
		\State \textbf{upon} \textit{receive($P2B, ballot, value, proofs$)} from acceptor $a$ \textbf{do}
		
		\State \hspace{\algorithmicindent} $storedProofs[ballot][value][a] = \langle a, proofs \rangle$;
		\State \hspace{\algorithmicindent} $valid\_proofs = 0$;
		\State \hspace{\algorithmicindent} \textbf{for} $i$ \textbf{in} $acceptors$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = proofs[i]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof_{pub_i} == \langle ballot, value \rangle$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} 
		$valid\_proofs \mathrel{+{=}} 1$;
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $valid\_proofs \geq N-s$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $validVotes[ballot][value][a] = proofs$;
		\State
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $quorumSize[ballot][value] = \bot$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $quorumSize[ballot][value] = N-s$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \Call{startTimer}{$3T, \textproc{timerEnded}, ballot, value$};
		\State
		\State \hspace{\algorithmicindent} \textbf{if} $(\#(validVotes[ballot][value]) \geq quorumSize[ballot][value]$ and $(quorumSize[ballot][value] = N-s$ or $verificationMessages[ballot][value] \geq N-u)$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $learned = \Call{merge\_sequences}{learned, value}$;
		
			\State
		\State \textbf{upon} \textit{receive($P2B, ballot, value$)} from acceptor $a$ \textbf{do}
		\State \hspace{\algorithmicindent} \textbf{if} $\Call{isUniversallyCommutative}{value}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}
		$validVotes[ballot][value][a] = true$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $\#(validVotes[ballot][value]) > u$ \textbf{then} 
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $learned = learned \bullet value$;
		
		\State
		\State \textbf{upon} \textit{receive($VERIFY\_RESP, ballot, value$)} from acceptor $a$ \textbf{do}
		\State \hspace{\algorithmicindent} $verificationMessages[ballot][value][a]  = true$;
		\State \hspace{\algorithmicindent} \textbf{if} $(\#(validVotes[ballot][value]) \geq quorumSize[ballot][value]$ and $(quorumSize[ballot][value] = N-s$ or $verificationMessages[ballot][value] \geq N-u)$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $learned = \Call{merge\_sequences}{learned, value}$;
		
		\State
		\State
		\textbf{function} \Call{timerEnded}{$ballot, value$}
		\State \hspace{\algorithmicindent} $quorumSize[ballot][value] = N-u$;

		\State
		\State \hspace{\algorithmicindent} \textbf{for} $a$ \textbf{in} $acceptors$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $acc\_proofs = storedProofs[a]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} $valid\_proofs = 0$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{for} $i$ \textbf{in} $acceptors$ \textbf{do}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $proof = acc\_proofs[i]$;
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $proof_{pub_i} == \langle ballot, value \rangle$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} 
		$valid\_proofs \mathrel{+{=}} 1$;
		\State
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent} \textbf{if} $valid\_proofs \geq N-u$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $validVotes[ballot][value][a] = proofs$;
		\State 		
		\State \hspace{\algorithmicindent} \Call{send}{$VERIFY\_REQ, ballot$} to acceptors;

		\State		
		\Function{merge\_sequences}{$old\_seq, new\_seq$}
		\State \textbf{for} $c$ \textbf{in} $new\_seq$ \textbf{do} 
		\State \hspace{\algorithmicindent} \textbf{if} $!\Call{contains}{old\_seq,c}$ \textbf{then}
		\State \hspace{\algorithmicindent}\hspace{\algorithmicindent}\hspace{\algorithmicindent} $old\_seq =  old\_seq \bullet c$;
		\State \textbf{return} $old\_seq$;
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsubsection{Timings}

One important aspect of the original Visigoth description is related to the setting of timeouts. In \acrshort{vft}, all processes are expected to initiate the quorum gathering so they may commit a value. The timeouts used by the \acrlong{qgp} to trigger the quorum reduction must be set according to both the upper bound on message latency between processes and the maximum relative delay that can be expected between two processes initiating the primitive. This is encoded in the following property guaranteed by Quorum Gathering Primitive: \par

\begin{displayquote}
\textit{Safety-Intersection}: if there are two instances of \acrshort{qgp}, such that all correct processes that are not crashed and not slow towards the respective gatherer processes initiate the protocol within $\delta$ time window such that $T+\delta < T_{QGP}$, then, if the two correct gatherers $p$ and $p'$ gather $M$ and $M'$ respectively, $M$ and $M'$ intersect in at least one correct replica.
\end{displayquote}

This specification is directly related to the fact that all correct processes are expected to gather messages from a quorum, which is why the timeout value $T_{QGP}$ must be larger than the synchrony bound $T$ plus the maximum time that can elapse between two processes initiating the gathering process $\delta$. However, since in our system model processes are differentiated by roles as in traditional Paxos, it only makes sense to have the gathering logic at the learners. This difference in system modeling requires us to reason about the maximum delay that can be displayed between two votes sent from the acceptors to the learners. Take the worst case scenario where two message paths display the biggest possible latency difference after being sent by the leader: in the first case, the phase $2a$ message reaches an acceptor almost immediately and triggers the sending of a phase $2b$ message that also reaches the learner almost immediately; the second message takes the maximum amount of time $T$ that a non-faulty and non-slow message can take to reach some acceptors. Consider that the leader is also Byzantine and ignores a subset of the acceptors. Due to this behavior, some acceptors will have to wait from the replay broadcast sent by other acceptors to be aware of the phase $2a$ messages. Suppose that both this message round and the corresponding phase $2b$ message that it triggers take $T$ time units to reach the intended recipients. In this case, a total of $3T$ message delays will separate the two message paths without either of them being faulty or slow. Therefore, the timeout value $T_{QGP}$ at the learners must be set to $3T$.

\subsubsection{Quorums}
There are several aspects of \acrshort{vgp} that are dependent on possible quorum sizes. As is the case with \acrshort{bgp}, we must ensure that the leader receives a phase $1b$ message from at least one correct acceptor relaying the most recently learned sequence along with enough proofs to ensure that no other non-commutative sequence may have been learned. Since the only aspect of the \acrshort{vgp} protocol that differs from \acrshort{bgp} is the procedure through which the quorums are gathered, the same reasoning for correctness applies. As long as quorums are guaranteed to intersect in more than $o$ acceptors, we are sure that two non-commutative sequences cannot both receive a quorum of verification messages. In order to demonstrate the protocol's correctness, subsection \ref{vft_proofs} shows that this condition is upheld for any two gathered quorums. \par
However, even though we are able of extending \acrshort{bgp} to the Visigoth model using VFT-SMaRt's \acrshort{qgp} to collect messages without introducing additional complexity to the protocol's message pattern, there exists some potential for conflict between the two protocols when we consider that they are designed to expect different quorum sizes. In particular, \acrshort{bgp} requires acceptors to gather $N-f$ proofs in order to ensure the leader of the following classic ballot that enough acceptors committed to some sequence. Since learners only learn after witnessing $N-f$ collections of such proofs, we also guarantee that, when a sequence is learned, not only no other non-commutative sequence is learned at the same ballot but the leader of the next classic ballot will be aware of every learned sequence. However, as we previously mentioned, \acrshort{vft} uses either a larger quorum of $N-s$ or a smaller quorum of $N-u$, during its message gathering procedure. Although the original VFT protocol proves that any two quorums intersect, it's unclear what effect the variable quorums have on the collection of proofs in the verification phase. In particular, when a learner receives a vote, he has no way of knowing whether to expect $N-s$ or $N-u$ proofs. \par 
In the interest of preserving safety, \acrshort{vgp} initially assumes that only the slow $s$ processes may be silent and requires at least $N-s$ proofs in order to accept a phase $2b$ message. If a phase $2b$ message carries with it less than $N-s$ proofs, it's not counted as a valid vote in phase $2b$. However, since we want the protocol to progress in the presence of faults, phase $2b$ messages that don't contain at least $N-s$ proofs are stored and, if the timeout lowers the minimum quorum size to $N-u$, the phase $2b$ messages are rechecked in order to see if they contain at least $N-u$ proofs, as can be seen in Algorithm \ref{VFT-Learn} lines \{30-42\}. It's important to note that the \acrshort{qgp} is only explicit at the learner due to space constraints. However, both the leader and the acceptors also implement the exact same behavior when gathering a quorum of messages. Therefore, when an acceptor gathers verification messages, it first waits for $N-s$ such messages but, after a timeout of $3T$, it can send its phase $2b$ vote with just $N-u$ votes.\par

\iffalse
One such invariant is that the leader must receive a phase $1b$ message from at least one correct acceptor that relays the most recently learned sequence along with enough proofs to ensure that no other non-commutative sequence may have been learned. In order to determine if this property is dependent on the size of the verification quorums, we assume the worst case scenario in which all the relayed verification quorums are composed of $N-u$ acceptors and intersect in the minimum possible number of processes. The intersection between any two such quorum is $(N-u)+(N-u)-N= 2o+2s+2-u-o-s-1= o+s+1-u$. The actual number of acceptors in the intersection depends on the parameterization of the protocol. It makes sense to tune the protocol for distinct values of the parameters $o$ and $s$ since intuitively the edge cases will demonstrate safety problems more clearly. \par
The first case occurs when we maximize both parameters such that $o=u$ and $s=u-1$. In this case, the intersection is $o+s+1-u=u+u-1+1-u=u$. At first it may seem that since the size of the intersection is $u$ and $o=u$, it's possible that no correct acceptors exist in the intersection between the two quorums. However, for the $N-u$ quorum to be gathered it's necessary that some acceptor remains silent since, for it to be impossible to gather a $N-s$ quorum, more than $s$ processes have to be silent. This means that even though the intersection is composed of only $u$ processes, not all of them will be faulty since at least one faulty process remained silent. Therefore, if an acceptor relays $N-u$ proofs that some value was accepted by a majority, no other non-commutative value may have been learned.\par
In the second case, we minimize both parameters such that $0=o$ and $s=0$. Since every process is synchronous, each gathered quorum would contain every correct process. Therefore, not only there are no Byzantine acceptors but quorums would always contain every correct process. The same reasoning applies in the case where $o=u$ and $s=0$ because, even though we're allowing for the maximum number of commission (i.e., Byzantine) faults, there are not enough faulty processes to reduce both quorums and control the the intersection between them. In the previous parameterization, since every acceptor process is synchronous, in order for the $N-s$ quorum to not be gathered it would require Byzantine processes to be silent \par

One such invariant is that, regardless of the size of the gathered quorums, the leader must receive a phase $1b$ message from at least one correct acceptor that relays the most recently learned sequence along with sufficient proofs. Naturally, this begs the question of how many proofs are "sufficient proofs". This can answered by noting that the goal of the proof collection is to allow an acceptor to attest that no other non-commutative value may have been voted for by a majority. Consider the most pessimistic parameterization of the fault model occurs when $o=u$. In this situation, the $o$ Byzantine acceptors can broadcast proofs for some sequence $s$ along with other $u+1$ acceptors. Since every faulty acceptor is Byzantine and those acceptors are replying to the quorum, we're sure that the gathered quorum is of dimension $N-s$. In the next classic ballot, the leader will try to gather a quorum of phase $1b$ messages. A possible avenue of attack for the Byzantine acceptors is to reply to the leader with an out of date sequence. Recall that the previous phase $2b$ quorum was of size $N-s$. If we remove $o$ acceptors that are replying with outdated sequences, $s$ acceptors that are in the phase $1b$ but not in the phase $2b$ quorum and another $s$ that were in the phase $2b$ quorum but not in the current phase $1b$ quorum, that still leaves us with $N-2s-o=u+\cancel{o}+\cancel{s}+1-s-\cancel{s}-\cancel{o}=u+1-s$ correct acceptors in the intersection of both quorums. Since our protocol already functions under the assumption that $u>s$, then it's clear that there are enough acceptors in the intersection that will relay the most recent learned sequence.\par
Another possible attack would be for Byzantine acceptors to artificially reduce the quorum in the verification phase of some sequence $s$ such that the acceptors could only gather $N-u$ proofs and then vote for some other non-commutative sequence $s'$. However, the purpose of the $N-u$ proofs is still met. In this situation, the quorum of verification messages for $s'$ is $N-s$ since we know that the $u$ processes that didn't participate in $s$'s quorum are the $o$ Byzantine acceptors that will attempt to have $s'$ learned. This means that the verification quorum of the sequence $s'$ will contain $N-s=u+\cancel{o}+\cancel{s}+1-\cancel{o}-\cancel{s}=u+1$ correct acceptors. These acceptors intersect with the $u+s+1$ acceptors that voted for $s$ and, for that reason, wouldn't vote for a non-commutative sequence such as $s'$.
\fi
\subsection{Discussion}

\subsubsection{Universally commutative commands}
As is the case with \acrlong{bgp}, there is the possibility of extending \acrshort{vgp} by handling universally commutative commands differently than commands that may not commute with others. Since the reduced coordination requirements needed to learn these commands have been discussed at length in other chapters, we will refrain from repeating the same points here. However, it's interesting to note how the command history problem (and its solution) are well suited for an adaptation to the \acrshort{vft} model, since the advantages of both are aligned. The Visigoth model's assumption makes it specially useful in a datacenter environment where not only coordinated malicious behavior is unlikely due to the high security barriers in place but also the majority of costs scale inversely with the system's throughput capability (i.e., higher traffic requires more servers, switches, cooling equipment). Using the commutativity assumption to reduce coordination requirements, a protocol that solves the command history problem can reduce both latency and the total number of messages exchanged. The extension of handling universally commutative commands increases the protocol's throughput and latency gains even further, such that the fault model, the consensus problem and the protocol's implementation all contribute to a distributed system well suited to be used in a datacenter-like environment.
