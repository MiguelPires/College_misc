{\color{red}--- OLD STUFF ----}\par
The Visigoth model is a broad and parameterizable non-crash fault model that allows the system administrator to configure the amount of synchrony and faults that he wishes to allow \cite{Porto2015}. Given the initial task of solving the generalized consensus problem in the Visigoth model, we chose Generalized Paxos as a starting point. To make the task of solving generalized consensus in this model simpler, the protocol was analyzed from two different standpoints: the synchrony model and the fault model. In the remainder of this section we will describe the advances made along each of these perspectives.  \par

\subsubsection{Fault Model} \label{Fault Model}
In appendix \ref{Pseudocode}, we present the Generalized Paxos protocol for a CFT model in a form that is simpler and clearer than the original formulation \cite{Lamport2005}. The original specification is written in TLA+ which is very precise but also difficult to understand. Our simplified algorithm separates the protocol by behavior, describing each role in an individual algorithm to aid comprehension. Algorithms \ref{alg:proposer} through \ref{alg:learner} implement the behavior of different roles that processes can embody in a Paxos system. Table \ref{table:1} defines the notation used in the pseudocode's specification in terms of concepts precisely defined in Lamport's \textit{Generalized Consensus and Paxos} paper \cite{Lamport2005}. This protocol solves the generalized consensus problem in its most generic form. By specifying what \textit{c-structs} belong in the same equivalence class, we could define a wide range of different consensus problems that could be solved with this algorithm. In the future, the consensus problem will be simplified to a command history problem and the description of the algorithm will be changed accordingly. \par 
The problem simplification is an important contribution due to the complexity of the original formulation. In the original specification, generalized consensus is specified in terms of \textit{c-structs} and requires \textit{c-structs} learned by learners to be compatible \cite{Lamport2005}. For two \textit{c-structs} to be compatible they must have a common upper bound, which is equivalent to requiring that they must be able to be extended to the same \textit{c-struct}. This is counter-intuitive since if two \textit{c-structs} contain differently ordered elements, they will never be equal. For instance, if we consider two \textit{c-structs} $A \bullet B \bullet \delta$ and $B \bullet A \bullet \delta$, regardless of what is appended in subsequent ballots, $\delta$, the \textit{c-structs} will always differ. The key is how we define \textit{equivalence}. Lamport specifies equivalence between \textit{c-structs} through an equivalence relation $\thicksim$. It's through this relation that different consensus problems can be formulated. The command history problem can be obtained by defining that two \textit{c-structs} are equivalent if one can be transformed into the other by permuting elements in a way such that the order of interfering commands is preserved. This means that two \textit{c-structs} are equivalent, $v \thicksim w$, if any pair of non-commutative commands have the same order. Taking the previous example, if $A$ and $B$ are commutative then the \textit{c-structs} $A \bullet B \bullet \delta$ and $B \bullet A \bullet \delta$ are equivalent regardless of the operations contained in $\delta$. However, this specification is too complex for a developer to deal with. By building this equivalence into the problem specification, we can make it easier to understand and reason about. Additionally, the protocol itself will also be greatly simplified since there will be no need to reason about upper bounds. An example of this complex reasoning can be seen in the \textit{Proved\_Safe(Q,m)} function of algorithm \ref{alg:leader}.

We now turn to the task of adapting Generalized Paxos for a non-crash variable fault model. To understand what is required of the protocol in this model, it's useful to consider the pessimistic end of the fault spectrum, Byzantine faults. A crash fault tolerance consensus-solving protocol can be adapted to support Byzantine fault tolerance by adding an additional broadcast round, authenticated channels and by using Byzantine quorums \cite{Cachin2009}. The additional round ensures that not only two quorums intersect within a view but also that a view change quorum intersects with other quorums, so that a committed value can't be ignored by a view change.
When considering Byzantine faults, it's not enough to ensure that quorums have a non-empty intersection, since the replicas in the intersection may be faulty. Therefore, it's necessary to ensure that any two Byzantine quorums intersect in at least $o+1$ replicas (or $f+1$ in the traditional notation). However, while this is a well known transformation of classic majority quorums, we need to apply a similar transformation to fast quorums since we wish to preserve fast ballots in the variable fault model. Generalized consensus' Approximate Theorem 3 states that the intersection between two fast quorums and a classic quorum must be non-empty \cite{Lamport2005}. This rule needs to be revised to ensure that the intersection is not only non-empty but also larger than $f$. We obtain the minimum quorum size by forcing the intersection between quorums to be larger than $f$ in the worst case scenario. In the worst case, given two fast quorums of size $Q_f$ and a classic quorum of size $Q_c$, $Q_c$ would intersect with all the replicas of the fast quorums that don't intersect with each other and with some replicas of the fast quorums that do intersect. We name $x$ as the intersection between the three quorums. To ensure agreement, we need to ensure that the intersection between the classic quorum and the two fast quorums, $x$, will have to be larger than $f$. Therefore, the following statements must always hold: \par

\begin{gather*}
	\begin{cases}
		Q_c \geq N - Q_f + N-Q_f + x \\
		x > f \\
		Q_c = \lceil \frac{N+f}{2}\rceil
	\end{cases} \\ 
\end{gather*}

The first equation states that the classic quorum is composed of the replicas of the fast quorums that don't intersect with each other plus some replicas that do intersect. The second equation forces the intersection to always be larger than $f$ and the third equation is the minimum quorum size for classic quorums. To solve the system, we can substitute the $Q_c$ in the first equation by $\lceil \frac{N+f}{2}\rceil$ and we obtain:
\begin{gather*} \\
	Q_c \geq N - Q_f + N-Q_f + x \label{eq_1} \tag{1} \\ 
	\lceil\frac{N+f}{2}\rceil \geq 2N - 2Q_f + x \label{eq_2} \tag{2} \\
	N+f \geq 4N - 4Q_f + 2x \label{eq_3} \tag{3} \\
	Q_f \geq \frac{3N+2x-f}{4} \label{eq_4} \tag{4} \\ 
	\text{Since $x > f$} \implies Q_f \geq \frac{3N+f+1}{4} \label{eq_5} \tag{5}  \\
\end{gather*}

Note that when transitioning from \eqref{eq_2} to \eqref{eq_3}, the ceiling operator was ignored. However, this is safe because, for any $x$, $y$ and $z$, if $\frac{x}{y} > z$ then $\lceil \frac{x}{y} \rceil > z$ holds.\par

\subsubsection{Synchrony Model}
Synchrony assumptions in the Visigoth model are represented through the $s$ variable which defines the number of processes $p_j$ that can be considered slow with respect to a process $p_i$. Recall that Visigoth allows the system administrator to specify precise synchrony and fault assumptions by configuring parameters for the number of slow processes, number of total faults and number of comission (i.e., arbitrary) faults, respectively, $s$, $u$ and $o$ \cite{Porto2015}. To adapt the Generalized Paxos protocol to the Visigoth model, it's useful to look at how VFT uses the synchrony assumption. In VFT, these additional assumptions regarding synchrony are encoded in the Quorum Gathering Primitive (QGP) which is responsible for gathering quorums in each round of the VFT protocol. This primitive sets a timer and tries to gather a quorum of $n-s$ (fast but potentially faulty) replicas  and, if a timeout occurs before the quorum is complete, the quorum is decreased to $n-u$ (slow but correct) replicas and a second verification quorum must also be gathered. The verification quorum ensures that two concurrent quorums intersect even if $n-s$ replicas aren't available. In an initial adaptation of Generalized Paxos, we adapted the protocol to Visigoth's broader synchrony assumptions using VFT's Quorum Gathering Primitive to gather quorums in fast ballots. Using QGP to gather quorums, we can reduce the system size from $n=2e+f+1$, where $e$ is the traditional Fast Paxos notation for the number of faults we can tolerate while still accepting fast ballots, to $n=u+s+1$ (in Visigoth notation) when $s < u$. Suppose we want to tolerate two faults, in Generalized Paxos this equates to $f=2$ which leaves us with the choice of how many faults we wish to tolerate while still accepting fast ballots, $e$. For values to be committed in fast ballots, we need to ensure two quorum intersection properties: $n > 2f$ and $n > 2e+f$ \cite{Lamport2006}. This means that by choosing $e=1$, the total number of replicas becomes $n= 5$. In contrast, Visigoth allows us to pick $u = 2$, $s = 1$ and the resulting system size is only $n = 4$. This reduction of the total number of required processes is also reflected in the fast quorum size. For the same fault threshold and fast accepting fault tolerance threshold, a fast quorum is $n-e$ in Generalized Paxos and $n-s$ in Visigoth. In the case of the previous example, if we wish to be able to accept fast ballots despite one fault, $n-e = 4$ and $n-s=3$. Additionally, the Visigoth model also reduces the size requirements for slow quorums. Taking the previous example, a classic quorum in Generalized Paxos would be $n-f = 3$ while the equivalent would be $n-u=2$ in Visigoth. The reason why this quorum size is enough to ensure safety is that we can leverage the known number of slow processes to reduce the quorum size in case of timeout. If the first quorum of $n-s$ replicas isn't gathered successfully because $x$ replicas didn't respond, since at most $s$ may be slow, $x-s$ must be faulty and won't participate in future quorums.  Therefore, by using VFT's Quorum Gathering Primitive, we could potentially increase the availability of fast ballots in the presence of failures, resulting in more proposals that are accepted while bypassing the leader. \par

\subsection{Future Work} \label{Future Work}

To develop a fully functional protocol to solve generalized consensus in the Visigoth model, we will develop our preliminary results with the same \textit{divide-and-conquer} approach as before, focusing separately on synchrony and fault tolerance. Regarding the fault tolerance, the protocol will be augmented to support the customizable faults that are defined in the Visigoth model. We already took initial steps in this direction by defining the fast quorum size for a Byzantine fault tolerant system (described in section \ref{Fault Model}). Future work will include incorporating these quorums, authenticated channels and an additional broadcast round into the Generalized Paxos protocol. This will turn the crash fault tolerant protocol into a Byzantine fault tolerant one. After that, the quorums will be transformed to use Visigoth's parameters regarding faults. This will require special care since for fast and classic ballots to be used, the system must obey additional quorum intersection rules such as generalized consensus' Approximate Theorem 3 \cite{Lamport2005}. Additionally, we will explore further how synchrony assumptions can be used in Generalized Paxos. This is a non-trivial endeavor since the previous usage of these assumptions in VFT's quorum gathering primitive follows a different logic and gathers quorums whose size can differ dynamically. \par
After developing a fully functioning protocol to solve generalized consensus in the Visigoth model, we will extract insights on how this can be used in certain scenarios. For instance, a protocol that solves a consensus problem for command histories while tolerating arbitrary and uncorrelated faults could be interesting in the case of a datacenter. Another potentially interesting scenario that makes use of different synchrony and faults models would be a multidatacenter setting where replicas in other datacenters are considered to be slow or potentially Byzantine and replicas in the same datacenter are considered synchronous and subject only to crash faults. These are the types of results we wish to obtain by solving the generalized consensus problem in the Visigoth model.\par
Additionally, we will also provide correctness proofs to ensure that our protocol provides the safety and liveness properties specified by generalized consensus under the Visigoth model. 
